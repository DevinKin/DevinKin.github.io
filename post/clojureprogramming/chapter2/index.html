<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Clojure编程-第二章-函数式编程 - Devinkin Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="devinkin" /><meta name="description" content="第2章-函数式编程 函数式编程(FP)在软件工程开发是一个模糊的概念。 什么是函数式编程 函数式编程是一个涵盖了许多语言级基本类型和功能的总称，不" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.69.2 with theme even" />


<link rel="canonical" href="https://devinkin.github.io/post/clojureprogramming/chapter2/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="https://devinkin.github.io/sass/main.min.8c3cbcb0324c2bb4875ceccba4007cbad4b4ac8377f33af9953c3e7684534a50.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Clojure编程-第二章-函数式编程" />
<meta property="og:description" content="第2章-函数式编程 函数式编程(FP)在软件工程开发是一个模糊的概念。 什么是函数式编程 函数式编程是一个涵盖了许多语言级基本类型和功能的总称，不" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://devinkin.github.io/post/clojureprogramming/chapter2/" />
<meta property="article:published_time" content="2020-04-18T15:10:11+08:00" />
<meta property="article:modified_time" content="2020-04-18T15:10:11+08:00" />
<meta itemprop="name" content="Clojure编程-第二章-函数式编程">
<meta itemprop="description" content="第2章-函数式编程 函数式编程(FP)在软件工程开发是一个模糊的概念。 什么是函数式编程 函数式编程是一个涵盖了许多语言级基本类型和功能的总称，不">
<meta itemprop="dateModified" content="2020-04-18T15:10:11&#43;08:00" />
<meta itemprop="wordCount" content="3148">



<meta itemprop="keywords" content="Clojure,Lisp," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Clojure编程-第二章-函数式编程"/>
<meta name="twitter:description" content="第2章-函数式编程 函数式编程(FP)在软件工程开发是一个模糊的概念。 什么是函数式编程 函数式编程是一个涵盖了许多语言级基本类型和功能的总称，不"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Devinkin</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Devinkin</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Clojure编程-第二章-函数式编程</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-04-18 </span>
        <div class="post-category">
            <a href="/categories/clojure/"> Clojure </a>
            </div>
          <span class="more-meta"> 约 3148 字 </span>
          <span class="more-meta"> 预计阅读 7 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#第2章-函数式编程">第2章-函数式编程</a>
      <ul>
        <li><a href="#什么是函数式编程">什么是函数式编程</a></li>
        <li><a href="#值的重要性">值的重要性</a></li>
        <li><a href="#一等函数和高阶函数">一等函数和高阶函数</a></li>
        <li><a href="#函数组合--功能">函数组合(功能)</a></li>
        <li><a href="#纯函数">纯函数</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="第2章-函数式编程">第2章-函数式编程</h2>
<p>函数式编程(FP)在软件工程开发是一个模糊的概念。</p>
<h3 id="什么是函数式编程">什么是函数式编程</h3>
<p>函数式编程是一个涵盖了许多语言级基本类型和功能的总称，不同的语言提供了不同的功能。</p>
<p>在Clojure，函数式编程的含义是</p>
<ul>
<li>优先处理不可变的值，这包括
<ul>
<li>使用满足简单抽象而不是可变状态包的不可变数据结构</li>
<li>将函数本身当作值处理，从而支持高阶函数</li>
</ul>
</li>
<li>优先于命令式控制结构和迭代的数据声明式处理</li>
<li>函数、高阶函数和不可变数据结构的自然增量组合，以便通过处理高级抽象来解决复杂问题</li>
</ul>
<p>Clojure对并发和并行提供了广泛的支持，为标志管理和状态改变提供了定义的语义。</p>
<h3 id="值的重要性">值的重要性</h3>
<p>程序状态概念是一个历史悠久的广义概念，但通常指的是所有代表整个应用程序的标量和总计数据结构，以及应用程序与外部世界维护的所有连接(如打开的文件、套接字等)。</p>
<p>函数式编程鼓励使用不可变对象，称为值，去代表程序的状态。</p>
<p>Clojure在并发上下文上无需担心这些map的键对应的值的线程安全性。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">h</span> <span class="p">{[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">]</span> <span class="mi">3</span><span class="p">})</span>
<span class="c1">;= #&#39;chapter1.core/h</span>

<span class="p">(</span><span class="nf">h</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">])</span>
<span class="c1">;= 3</span>

<span class="p">(</span><span class="nb">conj </span><span class="p">(</span><span class="nb">first </span><span class="p">(</span><span class="nb">keys </span><span class="nv">h</span><span class="p">))</span> <span class="mi">3</span><span class="p">)</span>
<span class="c1">;= [1 2 3]</span>

<span class="nv">h</span>
<span class="c1">;= {[1 2] 3}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="一等函数和高阶函数">一等函数和高阶函数</h3>
<p>函数本身是值(数据)。可以用作参数和返回值。</p>
<p>函数作为数据允许一种抽象方法，而没有一流的语言缺乏这种抽象方法。</p>
<p>一个函数调用其他函数两次的方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">call-twice</span> <span class="p">[</span><span class="nv">f</span> <span class="nv">x</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">f</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">f</span> <span class="nv">x</span><span class="p">))</span>

<span class="p">(</span><span class="nf">call-twice</span> <span class="nb">println </span><span class="mi">123</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p><code>map</code> 接受一个函数参数，和一个或多个集合。然后返回函数参数应用于所提供的集合的每个成员的序列。</p>
<ul>
<li><code>(map f [a b])</code> 等价于 <code>[(f a) (f b) (f c)]</code></li>
<li><code>(map f [a b c] [x y z])</code> 等价于 <code>[(f a x) (f b y) (f c z)]</code></li>
</ul>
<p><code>map</code> 的使用案例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">map </span><span class="nv">clojure.string/lower-case</span> <span class="p">[</span><span class="s">&#34;Java&#34;</span> <span class="s">&#34;Imperative&#34;</span> <span class="s">&#34;Weeping&#34;</span>
				<span class="s">&#34;Clojure&#34;</span> <span class="s">&#34;Learning&#34;</span> <span class="s">&#34;Peace&#34;</span><span class="p">])</span>
<span class="c1">;= (&#34;java&#34; &#34;imperative&#34; &#34;weeping&#34; &#34;clojure&#34; &#34;learning&#34; &#34;peace&#34;)</span>

<span class="p">(</span><span class="nb">map * </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">]</span> <span class="p">[</span><span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span><span class="p">])</span>
<span class="c1">;= (5 12 21 32)</span>
</code></pre></td></tr></table>
</div>
</div><p><code>reduce</code> 可以将一个函数应用到一个集合，灵活的产生任何值，这通常称为归约。</p>
<ul>
<li><code>reduce</code> 将集合中的每一项应用到函数中，积累并返回单个结果值。</li>
</ul>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">reduce max </span><span class="p">[</span><span class="mi">0</span> <span class="mi">-3</span> <span class="mi">10</span> <span class="mi">48</span><span class="p">])</span>
<span class="c1">;= 48</span>

<span class="c1">;= 等价于</span>
<span class="p">(</span><span class="nb">max </span><span class="mi">0</span> <span class="mi">-3</span><span class="p">)</span>
<span class="p">(</span><span class="nb">max </span><span class="mi">0</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">(</span><span class="nb">max </span><span class="mi">10</span> <span class="mi">48</span><span class="p">)</span>

<span class="c1">;= 或</span>
<span class="p">(</span><span class="nb">max </span><span class="p">(</span><span class="nb">max </span><span class="p">(</span><span class="nb">max </span><span class="mi">0</span> <span class="mi">-3</span><span class="p">)</span> <span class="mi">10</span><span class="p">)</span> <span class="mi">48</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p><code>reduce</code> 可以提供一个初始值作为种子值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">reduce + </span><span class="mi">50</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">])</span>
<span class="c1">;= 60</span>
</code></pre></td></tr></table>
</div>
</div><p>我们可以归并一个数字集合为一个map，其中数字作为键，数字的平方作为值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">reduce </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">m</span> <span class="nv">v</span><span class="p">]</span>
	  <span class="p">(</span><span class="nb">assoc </span><span class="nv">m</span> <span class="nv">v</span> <span class="p">(</span><span class="nb">* </span><span class="nv">v</span> <span class="nv">v</span><span class="p">)))</span> <span class="p">{}</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">])</span>
<span class="p">(</span><span class="nb">reduce </span><span class="o">#</span><span class="p">(</span><span class="nb">assoc </span><span class="nv">%</span> <span class="nv">%2</span> <span class="p">(</span><span class="nb">* </span><span class="nv">%2</span> <span class="nv">%2</span><span class="p">))</span> <span class="p">{}</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">])</span>
<span class="c1">;= {1 1, 2 4, 3 9, 4 16}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>{}</code> 是Clojure空map的字面量。</p>
<h4 id="函数应用">函数应用</h4>
<p>函数应用在Clojure可以使用 <code>apply</code> 指定</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">apply hash-map </span><span class="p">[</span><span class="ss">:a</span> <span class="mi">5</span> <span class="ss">:b</span> <span class="mi">6</span><span class="p">])</span>
<span class="c1">;= {:b 6, :a 5}</span>
</code></pre></td></tr></table>
</div>
</div><p>方便起见， <code>apply</code> 允许你在参数序列前加上任意数量的显式参数。在许多情况下，如果有一些独立的值以及一系列的参数，就可以避免创建包含独立参数的新序列。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">args</span> <span class="p">[</span><span class="mi">2</span> <span class="mi">-2</span> <span class="mi">10</span><span class="p">])</span>

<span class="p">(</span><span class="nb">apply * </span><span class="mf">0.5</span> <span class="mi">3</span> <span class="nv">args</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>由于函数应用将函数应用于序列集合中包含的参数， <code>apply</code> 必须提供该函数的所有参数。</p>
<p>在部分应用程序中，只能向函数提供部分参数，生成一个新的函数，在后面可以使用原始函数的其他参数调用该函数。</p>
<p>在Clojure中 <code>partial</code> 提供偏函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">only-strings</span> <span class="p">(</span><span class="nb">partial filter </span><span class="nv">string?</span><span class="p">))</span>
<span class="c1">;= #&#39;chapter1.core/only-strings</span>

<span class="p">(</span><span class="nf">only-strings</span> <span class="p">[</span><span class="s">&#34;a&#34;</span> <span class="mi">5</span> <span class="s">&#34;b&#34;</span> <span class="mi">6</span><span class="p">])</span>
<span class="c1">;= (&#34;a&#34; &#34;b&#34;)</span>
</code></pre></td></tr></table>
</div>
</div><p>偏函数通常用于许多上下文中，比如一些需要配置的函数(数据库连接指定那些字段要被指定)。这允许您轻松使用 <code>partial</code> 创建具有必要配置&quot;锁定&quot;此类函数的偏函数，不需要担心底层函数需要什么额外的参数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">database-lookup</span> <span class="p">(</span><span class="nb">partial </span><span class="nv">get-data</span> <span class="s">&#34;jdbc:mysql://...&#34;</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>由于潜在的高效机制(JVM方法调用机制)，Clojure使用 <code>apply</code> 调用 <code>partial</code> 返回的函数仍然比Python和Ruby快。</p>
<h4 id="偏函数和函数字面量的对比">偏函数和函数字面量的对比</h4>
<p>函数字面量是偏函数的超集。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="o">#</span><span class="p">(</span><span class="nb">filter string? </span><span class="nv">%</span><span class="p">)</span> <span class="p">[</span><span class="s">&#34;a&#34;</span> <span class="mi">5</span> <span class="s">&#34;b&#34;</span> <span class="mi">6</span><span class="p">])</span>
</code></pre></td></tr></table>
</div>
</div><p>然而，函数字面量不限制你只定义函数的初始化参数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="o">#</span><span class="p">(</span><span class="nb">filter </span><span class="nv">%</span> <span class="p">[</span><span class="s">&#34;a&#34;</span> <span class="mi">5</span> <span class="s">&#34;b&#34;</span> <span class="mi">6</span><span class="p">])</span> <span class="nv">string?</span><span class="p">)</span>
<span class="c1">;= (&#34;a&#34; &#34;b&#34;)</span>
<span class="p">(</span><span class="o">#</span><span class="p">(</span><span class="nb">filter </span><span class="nv">%</span> <span class="p">[</span><span class="s">&#34;a&#34;</span> <span class="mi">5</span> <span class="s">&#34;b&#34;</span> <span class="mi">6</span><span class="p">])</span> <span class="nv">number?</span><span class="p">)</span>
<span class="c1">;= (5 6)</span>
</code></pre></td></tr></table>
</div>
</div><p>函数字面量强制你在调用时完全指定所有的参数，而偏函数(parital)允许你忽略部分参数细节。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="c1">;; 报错，异常。</span>
<span class="p">(</span><span class="o">#</span><span class="p">(</span><span class="nb">map </span><span class="nv">*</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span> <span class="p">[</span><span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">]</span> <span class="p">[</span><span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">])</span>

<span class="p">(</span><span class="o">#</span><span class="p">(</span><span class="nb">map * </span><span class="nv">%</span> <span class="nv">%2</span> <span class="nv">%3</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span> <span class="p">[</span><span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">]</span> <span class="p">[</span><span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">])</span>
<span class="c1">;= (28 80 162)</span>

<span class="c1">;; 报错，异常</span>
<span class="p">(</span><span class="o">#</span><span class="p">(</span><span class="nb">map * </span><span class="nv">%</span> <span class="nv">%2</span> <span class="nv">%3</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span> <span class="p">[</span><span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">])</span>

<span class="p">(</span><span class="o">#</span><span class="p">(</span><span class="nb">apply map * </span><span class="nv">%</span><span class="o">&amp;</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span> <span class="p">[</span><span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">]</span> <span class="p">[</span><span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">])</span>
<span class="c1">;= (28 80 162)</span>

<span class="p">(</span><span class="o">#</span><span class="p">(</span><span class="nb">apply map * </span><span class="nv">%</span><span class="o">&amp;</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>
<span class="c1">;= (1 2 3)</span>

<span class="p">((</span><span class="nb">partial map </span><span class="nv">*</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span> <span class="p">[</span><span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">]</span> <span class="p">[</span><span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">])</span>
<span class="c1">;= (28 80 162)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="函数组合--功能">函数组合(功能)</h3>
<p>函数组合在函数式编程有十分独特的含义：</p>
<ul>
<li>给定一定数量的函数，它是一个函数创建的，该函数将其参数应用于所提供的其中一个函数，使用每个返回成功的结果作为下一个所提供函数的参数，通常与最初指定函数顺序相反。</li>
</ul>
<p>对一个求和值进行逻辑非操作并返回字符串</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">negated-sum-str</span>
  <span class="p">[</span><span class="o">&amp;</span> <span class="nv">numbers</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">str </span><span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">apply + </span><span class="nv">numbers</span><span class="p">))))</span>
<span class="c1">;= #&#39;chapter2.core/negated-sum-str</span>
<span class="p">(</span><span class="nf">negated-sum-str</span> <span class="mi">10</span> <span class="mi">12</span> <span class="mf">3.4</span><span class="p">)</span>
<span class="c1">;= &#34;-25.4&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>在Clojure中可以使用 <code>comp</code> 进行函数组合。可以使得函数组合更简洁方便。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">negated-sum-str</span> <span class="p">(</span><span class="nb">comp str - </span><span class="nv">+</span><span class="p">))</span>
<span class="c1">;= #&#39;chapter2.core/negated-sum-str</span>
<span class="p">(</span><span class="nf">negated-sum-str</span> <span class="mi">10</span> <span class="mi">12</span> <span class="mf">3.4</span><span class="p">)</span>
<span class="c1">;= &#34;-25.4&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p><code>comp</code> 唯一的限制就是在组合中每个函数的返回值都必须和前者函数的参数相匹配。</p>
<p><code>comp</code> 可以用于建立高效的函数链，无论在单个组合中，还是作为组合本身就是 <code>comp</code> 产生的函数的结果。</p>
<p>将小写，使用 <code>-</code> 分隔的风格配置转换为驼峰配置的组合函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.string</span> <span class="ss">:as</span> <span class="nv">str</span><span class="p">])</span>

<span class="p">(</span><span class="k">def </span><span class="nv">camel-&gt;keyword</span> <span class="p">(</span><span class="nb">comp </span><span class="nv">keyword</span>
		       <span class="nv">str/join</span>
		       <span class="p">(</span><span class="nb">partial </span><span class="nv">interpose</span> <span class="sc">\-</span><span class="p">)</span>
		       <span class="p">(</span><span class="nb">partial map </span><span class="nv">str/lower-case</span><span class="p">)</span>
		       <span class="o">#</span><span class="p">(</span><span class="nf">str/split</span> <span class="nv">%</span> <span class="o">#</span><span class="s">&#34;(?&lt;=[a-z])(?=[A-Z])&#34;</span><span class="p">)))</span>
<span class="c1">;= #&#39;chapter2.core/camel-&gt;keyword</span>

<span class="p">(</span><span class="nf">camel-&gt;keyword</span> <span class="s">&#34;CamelCase&#34;</span><span class="p">)</span>
<span class="c1">;= :camel-case</span>
<span class="p">(</span><span class="nf">camel-&gt;keyword</span> <span class="s">&#34;lowerCamelCase&#34;</span><span class="p">)</span>
<span class="c1">;= :lower-camel-case</span>
</code></pre></td></tr></table>
</div>
</div><p>可以使用 <code>-&gt;</code> 和 <code>-&gt;&gt;</code> 宏达到 <code>comp</code> 组合函数的效果。作为宏，他们不会对函数进行操作。相反，它们会重新排列您提供给“thread”的代码，将值或集合作为每个形式中的第一个或最后一个参数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">camel-&gt;keywordv2</span>
  <span class="p">[</span><span class="nv">s</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="p">(</span><span class="nf">str/split</span> <span class="nv">s</span> <span class="o">#</span><span class="s">&#34;(?&lt;=[a-z](?=[A-Z]))&#34;</span><span class="p">)</span>
       <span class="p">(</span><span class="nb">map </span><span class="nv">str/lower-case</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">interpose</span> <span class="sc">\-</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">str/join</span><span class="p">)</span>
       <span class="nv">keyword</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>我们可以使用 <code>camel-&gt;keyword</code> 作为组合函数的一部分，定义一个函数返回使用驼峰形式的键的键值对序列的Clojure映射。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">camel-pairs-map</span>
  <span class="p">(</span><span class="nb">comp </span><span class="p">(</span><span class="nb">partial apply </span><span class="nv">hash-map</span><span class="p">)</span>
     <span class="p">(</span><span class="nb">partial </span><span class="nv">map-indexed</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">i</span> <span class="nv">x</span><span class="p">]</span>
			    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">odd?</span> <span class="nv">i</span><span class="p">)</span>
			      <span class="nv">x</span>
			      <span class="p">(</span><span class="nf">camel-&gt;keywordv2</span> <span class="nv">x</span><span class="p">))))))</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="编写高阶函数">编写高阶函数</h4>
<p>由 <code>comp</code> 体现的函数组合概念只是组合函数的一种可能方式。</p>
<p>虽然Clojure提供了很多通用的高阶函数，但不是为了通用的目的而保留的。</p>
<p>只有在函数和高阶函数之间指定契约，才能更复杂，更实用的组合。</p>
<p>一个返回其参数相加的高阶函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">adder</span>
  <span class="p">[</span><span class="nv">n</span><span class="p">]</span>
  <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">n</span> <span class="nv">x</span><span class="p">)))</span>
<span class="c1">;= ((adder 5) 18)</span>
<span class="c1">;= 23</span>
</code></pre></td></tr></table>
</div>
</div><p>将参数加倍的高阶函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">doubler</span>
  <span class="p">[</span><span class="nv">f</span><span class="p">]</span>
  <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="o">&amp;</span> <span class="nv">args</span><span class="p">]</span>
    <span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="p">(</span><span class="nb">apply </span><span class="nv">f</span> <span class="nv">args</span><span class="p">))))</span>
<span class="c1">;= (def doubler-+ (doubler +))</span>
<span class="c1">;= #&#39;chapter2.core/doubler-+</span>
<span class="c1">;= (doubler-+ 1 2 3)</span>
<span class="c1">;= 12</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="使用可组合高阶函数建立一个原始的日志系统">使用可组合高阶函数建立一个原始的日志系统</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">print-logger</span>
  <span class="p">[</span><span class="nv">writer</span><span class="p">]</span>
  <span class="o">#</span><span class="p">(</span><span class="nb">binding </span><span class="p">[</span><span class="nv">*out*</span> <span class="nv">writer</span><span class="p">]</span>
	 <span class="p">(</span><span class="nb">println </span><span class="nv">%</span><span class="p">)))</span>

<span class="c1">;; write to console</span>
<span class="p">(</span><span class="k">def </span><span class="nv">*out*-logger</span> <span class="p">(</span><span class="nf">print-logger</span> <span class="nv">*out*</span><span class="p">))</span>
<span class="p">(</span><span class="nf">*out*-logger</span> <span class="s">&#34;hello&#34;</span><span class="p">)</span>


<span class="c1">;; write to memory</span>
<span class="p">(</span><span class="k">def </span><span class="nv">writer</span> <span class="p">(</span><span class="nf">java.io.StringWriter.</span><span class="p">))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">retained-logger</span> <span class="p">(</span><span class="nf">print-logger</span> <span class="nv">writer</span><span class="p">))</span>
<span class="p">(</span><span class="nf">retained-logger</span> <span class="s">&#34;hello&#34;</span><span class="p">)</span>
<span class="p">(</span><span class="nb">str </span><span class="nv">writer</span><span class="p">)</span>

<span class="c1">;; write to file</span>
<span class="p">(</span><span class="nf">require</span> <span class="ss">&#39;clojure.java.io</span><span class="p">)</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">file-logger</span>
  <span class="p">[</span><span class="nv">file</span><span class="p">]</span>
  <span class="o">#</span><span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">f</span> <span class="p">(</span><span class="nf">clojure.java.io/writer</span> <span class="nv">file</span> <span class="ss">:append</span> <span class="nv">true</span><span class="p">)]</span>
     <span class="p">((</span><span class="nf">print-logger</span> <span class="nv">f</span><span class="p">)</span> <span class="nv">%</span><span class="p">)))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">log-&gt;file</span> <span class="p">(</span><span class="nf">file-logger</span> <span class="s">&#34;messages.log&#34;</span><span class="p">))</span>
<span class="p">(</span><span class="nf">log-&gt;file</span> <span class="s">&#34;hello&#34;</span><span class="p">)</span>


<span class="c1">;; multiple destinations</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">multi-logger</span>
  <span class="p">[</span><span class="o">&amp;</span> <span class="nv">logger-fns</span><span class="p">]</span>
  <span class="o">#</span><span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">f</span> <span class="nv">logger-fns</span><span class="p">]</span>
     <span class="p">(</span><span class="nf">f</span> <span class="nv">%</span><span class="p">)))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">log</span> <span class="p">(</span><span class="nf">multi-logger</span>
	  <span class="p">(</span><span class="nf">print-logger</span> <span class="nv">*out*</span><span class="p">)</span>
	  <span class="p">(</span><span class="nf">file-logger</span> <span class="s">&#34;messages.log&#34;</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">log</span> <span class="s">&#34;Hello again!&#34;</span><span class="p">)</span>


<span class="c1">;; timestamp logger</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">timestamped-logger</span>
  <span class="p">[</span><span class="nv">logger</span><span class="p">]</span>
  <span class="o">#</span><span class="p">(</span><span class="nf">logger</span> <span class="p">(</span><span class="nf">format</span> <span class="s">&#34;[%1$tY-%1$tm-%1$te %1$tH:%1$tM:%1$tS] %2$s&#34;</span> <span class="p">(</span><span class="nf">java.util.Date.</span><span class="p">)</span> <span class="nv">%</span><span class="p">)))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">log-timestamped</span> <span class="p">(</span><span class="nf">timestamped-logger</span>
		      <span class="p">(</span><span class="nf">multi-logger</span>
		       <span class="p">(</span><span class="nf">print-logger</span> <span class="nv">*out*</span><span class="p">)</span>
		       <span class="p">(</span><span class="nf">file-logger</span> <span class="s">&#34;messages.log&#34;</span><span class="p">))))</span>
<span class="p">(</span><span class="nf">log-timestamped</span> <span class="s">&#34;goodbye, now&#34;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="纯函数">纯函数</h3>
<p>接受一个Twitter用户名并返回粉丝数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">require</span> <span class="ss">&#39;clojure.xml</span><span class="p">)</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">twitter-followers</span>
  <span class="p">[</span><span class="nv">username</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="p">(</span><span class="nb">str </span><span class="s">&#34;https://api.twitter.com/1/users/show.xml?screen_name=&#34;</span> <span class="nv">username</span><span class="p">)</span>
       <span class="nv">clojure.xml/parse</span>
       <span class="ss">:content</span>
       <span class="p">(</span><span class="nb">filter </span><span class="p">(</span><span class="nb">comp </span><span class="o">#</span><span class="p">{</span><span class="ss">:followers_count</span><span class="p">}</span> <span class="ss">:tag</span><span class="p">))</span>
       <span class="nv">first</span>
       <span class="ss">:content</span>
       <span class="nv">first</span>
       <span class="nv">Integer/parseInt</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p><code>+</code> 不依赖它的环境，没有产生副作用，并且在相同参数情况下返回相同的结果。</p>
<h4 id="为什么纯函数这么有趣">为什么纯函数这么有趣？</h4>
<p>纯函数可以对编写软件的实践和经验产生深远的简化效果，特别是使用一组功能强大的不可变值类型相结合。</p>
<p>纯函数的优点：</p>
<ul>
<li>更容易推理</li>
<li>更容易测试</li>
<li>可缓存的，并行化简单(记忆)</li>
</ul>
<p>因为纯函数接收相同的实参返回相同的结果，可以用于缓存上一次使用该参数调用该函数的结果，并缓存该结果，该技术为记忆化技术。</p>
<p>记忆化技术可以用于解决各种计算量很大的算法问题，将相同参数的调用函数的结果缓存，并在下次使用相同参数调用函数时返回该结果。</p>
<p>clojure包含了一个名为 <code>memoize</code> 的实现，用函数调用它将返回另一个已记忆的函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">prime?</span>
  <span class="p">[</span><span class="nv">n</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">cond</span>
    <span class="p">(</span><span class="nb">== </span><span class="mi">1</span> <span class="nv">n</span><span class="p">)</span> <span class="nv">false</span>
    <span class="p">(</span><span class="nb">== </span><span class="mi">2</span> <span class="nv">n</span><span class="p">)</span> <span class="nv">true</span>
    <span class="p">(</span><span class="nf">even?</span> <span class="nv">n</span><span class="p">)</span> <span class="nv">false</span>
    <span class="ss">:else</span> <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="p">(</span><span class="nb">range </span><span class="mi">3</span> <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nf">Math/sqrt</span> <span class="nv">n</span><span class="p">))</span> <span class="mi">2</span><span class="p">)</span>
	       <span class="p">(</span><span class="nb">filter </span><span class="o">#</span><span class="p">(</span><span class="nb">zero? </span><span class="p">(</span><span class="nb">rem </span><span class="nv">n</span> <span class="nv">%</span><span class="p">)))</span>
	       <span class="nv">empty?</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">time </span><span class="p">(</span><span class="nf">prime?</span> <span class="mi">1125899906842679</span><span class="p">))</span>
<span class="c1">;= &#34;Elapsed time: 848.2982 msecs&#34;</span>
<span class="c1">;= true</span>

<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">m-prime?</span> <span class="p">(</span><span class="nf">memoize</span> <span class="nv">prime?</span><span class="p">)]</span>
  <span class="p">(</span><span class="nb">time </span><span class="p">(</span><span class="nf">m-prime?</span> <span class="mi">1125899906842679</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">time </span><span class="p">(</span><span class="nf">m-prime?</span> <span class="mi">1125899906842679</span><span class="p">)))</span>
<span class="c1">;= &#34;Elapsed time: 887.0941 msecs&#34;</span>
<span class="c1">;= &#34;Elapsed time: 0.0202 msecs&#34;</span>
<span class="c1">;= true</span>
</code></pre></td></tr></table>
</div>
</div><p>带有副作用的函数都是引用不透明的，因此通常使用记忆化不安全。当返回一个记忆化结果时，底层函数可能引起或依赖的任何副作用都不会发生。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">repeatedly</span> <span class="mi">10</span> <span class="p">(</span><span class="nb">partial rand-int </span><span class="mi">10</span><span class="p">))</span>
<span class="c1">;= (0 9 8 8 4 2 3 5 6 8)</span>
<span class="p">(</span><span class="nf">repeatedly</span> <span class="mi">10</span> <span class="p">(</span><span class="nb">partial </span><span class="p">(</span><span class="nf">memoize</span> <span class="nv">rand-int</span><span class="p">)</span> <span class="mi">10</span><span class="p">))</span>
<span class="c1">;= (3 3 3 3 3 3 3 3 3 3)</span>
</code></pre></td></tr></table>
</div>
</div><p>为了实现记忆化这个技术，所有调用函数的参数和返回值都会保存起来，不会被垃圾回收机制回收。</p>
<p>因此，具有高度可变域或特别内存密集型参数或返回值的记忆函数通常是内存&quot;泄露&quot;的源头，特别是当他们在顶层使用类似 <code>def</code> 定义等类似操作。</p>
<p>记忆化容易造成内存泄漏的解决方案：</p>
<ul>
<li>严格控制记忆函数的范围，我们不在顶层vars中定义记忆函数，根据需要在高阶函数调用本地创建的记忆化函数。</li>
<li>使用 <code>core.memoize</code> ，可以提供多种不同记忆化策略。包括过期缓存的参数和基于各种标准返回值的参数。</li>
</ul>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">devinkin</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2020-04-18
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/clojure/">Clojure</a>
          <a href="/tags/lisp/">Lisp</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/clojureprogramming/chapter3/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Clojure编程-第三章-集合和数据结构</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/clojureprogramming/chapter1/">
            <span class="next-text nav-default">Clojure编程-第一章-Clojure简介</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="https://github.com/DevinKin" class="iconfont icon-github" title="github"></a>
  <a href="https://devinkin.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2019 - 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">devinkin</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="https://devinkin.github.io/js/main.4d21c1cefdf1cd0b77ef59bab2d1bbe3112fc9d6cc04710bb1f0b1fd7b891f11.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"  integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>








</body>
</html>
