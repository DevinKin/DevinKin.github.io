<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Clojure编程-第三章-集合和数据结构 - Devinkin Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="devinkin" /><meta name="description" content="集合和数据结构 Maps 、 vectors 、 sets 和 lists 是Clojure提供的基本数据结构。以下是这些数据结构的字面表示形式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 &amp;#39;(a b :name 12.5) ;;list [&amp;#39;a &amp;#39;b" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.69.1 with theme even" />


<link rel="canonical" href="https://devinkin.github.io/post/clojureprogramming/chapter3/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="https://devinkin.github.io/sass/main.min.8c3cbcb0324c2bb4875ceccba4007cbad4b4ac8377f33af9953c3e7684534a50.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Clojure编程-第三章-集合和数据结构" />
<meta property="og:description" content="集合和数据结构 Maps 、 vectors 、 sets 和 lists 是Clojure提供的基本数据结构。以下是这些数据结构的字面表示形式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 &#39;(a b :name 12.5) ;;list [&#39;a &#39;b" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://devinkin.github.io/post/clojureprogramming/chapter3/" />
<meta property="article:published_time" content="2020-04-18T15:11:07+08:00" />
<meta property="article:modified_time" content="2020-04-18T15:11:07+08:00" />
<meta itemprop="name" content="Clojure编程-第三章-集合和数据结构">
<meta itemprop="description" content="集合和数据结构 Maps 、 vectors 、 sets 和 lists 是Clojure提供的基本数据结构。以下是这些数据结构的字面表示形式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 &#39;(a b :name 12.5) ;;list [&#39;a &#39;b">
<meta itemprop="dateModified" content="2020-04-18T15:11:07&#43;08:00" />
<meta itemprop="wordCount" content="10043">



<meta itemprop="keywords" content="Clojure,Lisp," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Clojure编程-第三章-集合和数据结构"/>
<meta name="twitter:description" content="集合和数据结构 Maps 、 vectors 、 sets 和 lists 是Clojure提供的基本数据结构。以下是这些数据结构的字面表示形式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 &#39;(a b :name 12.5) ;;list [&#39;a &#39;b"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Devinkin</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Devinkin</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Clojure编程-第三章-集合和数据结构</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-04-18 </span>
        <div class="post-category">
            <a href="/categories/clojure/"> Clojure </a>
            </div>
          <span class="more-meta"> 约 10043 字 </span>
          <span class="more-meta"> 预计阅读 21 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#集合和数据结构">集合和数据结构</a>
      <ul>
        <li><a href="#抽象大于实现">抽象大于实现</a></li>
        <li><a href="#访问集合">访问集合</a></li>
        <li><a href="#数据结构类型">数据结构类型</a></li>
        <li><a href="#不可变和持久性">不可变和持久性</a></li>
        <li><a href="#元数据">元数据</a></li>
        <li><a href="#导航-更新和zipper">导航,更新和zipper</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="集合和数据结构">集合和数据结构</h2>
<p><code>Maps</code> 、 <code>vectors</code> 、 <code>sets</code> 和 <code>lists</code> 是Clojure提供的基本数据结构。以下是这些数据结构的字面表示形式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="o">&#39;</span><span class="p">(</span><span class="nf">a</span> <span class="nv">b</span> <span class="ss">:name</span> <span class="mf">12.5</span><span class="p">)</span> <span class="c1">;;list</span>

<span class="p">[</span><span class="ss">&#39;a</span> <span class="ss">&#39;b</span> <span class="ss">:name</span> <span class="mf">12.5</span><span class="p">]</span>  <span class="c1">;;vector</span>

<span class="p">{</span><span class="ss">:name</span> <span class="s">&#34;Chas&#34;</span> <span class="ss">:age</span> <span class="mi">31</span><span class="p">}</span> <span class="c1">;;map</span>

<span class="o">#</span><span class="p">{</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">}</span>  <span class="c1">;; set</span>

<span class="p">{</span><span class="nv">Math/PI</span> <span class="s">&#34;~3.14&#34;</span>
 <span class="p">[</span><span class="ss">:composite</span> <span class="s">&#34;key&#34;</span><span class="p">]</span> <span class="mi">42</span>
 <span class="nv">nil</span> <span class="s">&#34;nothing&#34;</span><span class="p">}</span>   <span class="c1">;; another map</span>

<span class="o">#</span><span class="p">{{</span><span class="ss">:fist-name</span> <span class="s">&#34;chas&#34;</span> <span class="ss">:last-name</span> <span class="s">&#34;emerick&#34;</span><span class="p">}</span>
   <span class="p">{</span><span class="ss">:first-name</span> <span class="s">&#34;brian&#34;</span> <span class="ss">:last-name</span> <span class="s">&#34;carper&#34;</span><span class="p">}</span>
   <span class="p">{</span><span class="ss">:first-name</span> <span class="s">&#34;christophe&#34;</span> <span class="ss">:last-name</span> <span class="s">&#34;grand&#34;</span><span class="p">}}</span>  <span class="c1">;; a set of map</span>
</code></pre></td></tr></table>
</div>
</div><p>Clojure数据结构有两个独特的特征</p>
<ul>
<li>它们首先用于抽象，而不是具体实现的细节。</li>
<li>它们是不可变和持久的，对于Clojure高效的函数式编程风格，都必不可少的。</li>
</ul>
<h3 id="抽象大于实现">抽象大于实现</h3>
<p>Clojure集合抽象优于标准实现。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">v</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>
<span class="c1">;= #&#39;chapter3.core/v</span>
<span class="p">(</span><span class="nb">conj </span><span class="nv">v</span> <span class="mi">4</span><span class="p">)</span>
<span class="c1">;= [1 2 3 4]</span>
<span class="p">(</span><span class="nb">conj </span><span class="nv">v</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span>
<span class="c1">;= [1 2 3 4 5]</span>
<span class="p">(</span><span class="nb">seq </span><span class="nv">v</span><span class="p">)</span>
<span class="c1">;= (1 2 3)</span>
</code></pre></td></tr></table>
</div>
</div><p><code>seq</code> 总是在集合上生成一个顺序的视图，称为序列。</p>
<p><code>conj</code> 添加一个新值到给定的集合中。</p>
<p><code>seq</code> 和 <code>conj</code> 作用于 <code>map</code> ， <code>set</code> ， <code>list</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">m</span> <span class="p">{</span><span class="ss">:a</span> <span class="mi">5</span> <span class="ss">:b</span> <span class="mi">6</span><span class="p">})</span>
<span class="c1">;= #&#39;chapter3.core/m</span>
<span class="p">(</span><span class="nb">conj </span><span class="nv">m</span> <span class="p">[</span><span class="ss">:c</span> <span class="mi">7</span><span class="p">])</span>
<span class="c1">;= {:a 5, :b 6, :c 7}</span>
<span class="p">(</span><span class="nb">seq </span><span class="nv">m</span><span class="p">)</span>
<span class="c1">;= ([:a 5] [:b 6])</span>


<span class="p">(</span><span class="k">def </span><span class="nv">s</span> <span class="o">#</span><span class="p">{</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">})</span>
<span class="c1">;= #&#39;chapter3.core/s</span>
<span class="p">(</span><span class="nb">conj </span><span class="nv">s</span> <span class="mi">10</span><span class="p">)</span>
<span class="c1">;= #{1 3 2 10}</span>
<span class="p">(</span><span class="nb">seq </span><span class="nv">s</span><span class="p">)</span>
<span class="c1">;= (1 3 2)</span>

<span class="p">(</span><span class="k">def </span><span class="nv">lst</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="c1">;= #&#39;chapter3.core/lst</span>
<span class="p">(</span><span class="nb">conj </span><span class="nv">lst</span> <span class="mi">0</span><span class="p">)</span>
<span class="c1">;= (0 1 2 3)</span>
<span class="p">(</span><span class="nb">conj </span><span class="nv">lst</span> <span class="mi">0</span> <span class="mi">-1</span><span class="p">)</span>
<span class="c1">;= (-1 0 1 2 3)</span>
<span class="p">(</span><span class="nb">seq </span><span class="nv">lst</span><span class="p">)</span>
<span class="c1">;= (1 2 3)</span>
</code></pre></td></tr></table>
</div>
</div><p>Clojure的本质是拥有小型的，可访问的api，并在其上构建辅助函数.</p>
<p><code>into</code> 建立在 <code>seq</code> 和 <code>conj</code> 之上, 意味着 <code>into</code> 自动处理任何支持 <code>seq</code> 和 <code>conj</code> 上的值.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">into </span><span class="nv">v</span> <span class="p">[</span><span class="mi">4</span> <span class="mi">5</span><span class="p">])</span>
<span class="c1">;= [1 2 3 4 5]</span>

<span class="p">(</span><span class="nb">into </span><span class="nv">m</span> <span class="p">[[</span><span class="ss">:c</span> <span class="mi">7</span><span class="p">]</span> <span class="p">[</span><span class="ss">:d</span> <span class="mi">8</span><span class="p">]])</span>
<span class="c1">;= {:a 5, :b 6, :c 7, :d 8}</span>

<span class="p">(</span><span class="nb">into </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span> <span class="mi">2</span><span class="p">}</span> <span class="p">[</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">3</span> <span class="mi">3</span> <span class="mi">2</span><span class="p">])</span>
<span class="c1">;= #{1 4 3 2 5}</span>

<span class="p">(</span><span class="nb">into </span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span><span class="ss">:a</span> <span class="mi">1</span> <span class="ss">:b</span> <span class="mi">2</span><span class="p">})</span>
<span class="c1">;= [1 [:a 1] [:b 2]]</span>
</code></pre></td></tr></table>
</div>
</div><p>Clojure鼓励使用统一抽象(序列, 协议, 集合接口等), 让您从显式地依赖于具体类型的特定行为分离出来.</p>
<p>Clojure的数据结构参与实现了七个不同的主要抽象.</p>
<ul>
<li>Collection</li>
<li>Sequence</li>
<li>Associative</li>
<li>Indexed</li>
<li>Stack</li>
<li>Set</li>
<li>Sorted</li>
</ul>
<h4 id="集合">集合</h4>
<p>集合可以与一组的核心集合函数一起使用的值.</p>
<ul>
<li><code>conj</code> 添加一项到集合中</li>
<li><code>seq</code> 获取集合的序列</li>
<li><code>count</code> 获取集合中项数量</li>
<li><code>empty</code> 获取和提供的集合相同类型的空实例</li>
<li><code>=</code> 去确定集合的值是否相等</li>
</ul>
<p>上述的函数都是多态的, 不管操作集合的具体类型是什么.</p>
<p><code>empty</code> 通常处理与给定实例相同的集合. <code>empty</code> 的语义允许一个空的数据结构, 我们可以保证它与调用者提供的是相同的具体类型.</p>
<p>一个交换序列集合中的值对</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">swap-pairs</span>
  <span class="p">[</span><span class="nv">sequentail</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">into </span><span class="p">(</span><span class="nf">empty</span> <span class="nv">sequentail</span><span class="p">)</span>
	<span class="p">(</span><span class="nf">interleave</span>
	 <span class="p">(</span><span class="nb">take-nth </span><span class="mi">2</span> <span class="p">(</span><span class="nb">drop </span><span class="mi">1</span> <span class="nv">sequentail</span><span class="p">))</span>
	 <span class="p">(</span><span class="nb">take-nth </span><span class="mi">2</span> <span class="nv">sequentail</span><span class="p">))))</span>
<span class="c1">;= (swap-pairs (apply list (range 10)))</span>
<span class="c1">;= (8 9 6 7 4 5 2 3 0 1)</span>
<span class="c1">;= (swap-pairs (apply vector (range 10)))</span>
<span class="c1">;= [1 0 3 2 5 4 7 6 9 8]</span>
</code></pre></td></tr></table>
</div>
</div><p>返回的映射结果保留了其他提供的映射的排序保证.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">map-map</span>
  <span class="p">[</span><span class="nv">f</span> <span class="nv">m</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">into </span><span class="p">(</span><span class="nf">empty</span> <span class="nv">m</span><span class="p">)</span>
	<span class="p">(</span><span class="nb">for </span><span class="p">[[</span><span class="nv">k</span> <span class="nv">v</span><span class="p">]</span> <span class="nv">m</span><span class="p">]</span>
	  <span class="p">[</span><span class="nv">k</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">j</span> <span class="nv">v</span><span class="p">)])))</span>
<span class="c1">;= (map-map inc (hash-map :z 5 :c 6 :a 0))</span>
<span class="c1">;= {:z 6, :c 7, :a 1}</span>

<span class="p">(</span><span class="nf">map-map</span> <span class="nb">inc </span><span class="p">(</span><span class="nb">sorted-map </span><span class="ss">:z</span> <span class="mi">5</span> <span class="ss">:c</span> <span class="mi">6</span> <span class="ss">:a</span> <span class="mi">0</span><span class="p">))</span>
<span class="c1">;= {:a 1, :c 7, :z 6}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>count</code> 表明整个集合的项数. 保证了对除序列之外所有集合进行有效的操作.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">count </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>
<span class="c1">;= 3</span>
<span class="p">(</span><span class="nb">count </span><span class="p">{</span><span class="ss">:a</span> <span class="mi">1</span> <span class="ss">:b</span> <span class="mi">2</span> <span class="ss">:c</span> <span class="mi">3</span><span class="p">})</span>
<span class="c1">;= 3</span>
<span class="p">(</span><span class="nb">count </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">})</span>
<span class="c1">;= 3</span>
<span class="p">(</span><span class="nb">count </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="c1">;= 3</span>
</code></pre></td></tr></table>
</div>
</div><p><code>count</code> 对非Clojure集合的Java类型是否有用, 像 <code>Strings, maps, collections, arrays</code></p>
<h4 id="序列">序列</h4>
<p>序列抽象定义了一种方法来获取和遍历某种值源上的序列视图.</p>
<ul>
<li>另一个集合</li>
<li>某些计算结果的连续值</li>
</ul>
<p>序列通常称为 <code>seqs</code> , 除了集合抽象提供的基础之外, 还涉及几个操作.</p>
<ul>
<li><code>seq</code> 从参数中生成一个序列.</li>
<li><code>first</code> , <code>rest</code> 和 <code>next</code> 提供消费序列的方式.</li>
<li><code>lazy-seq</code> 生成一个惰性序列, 这是求值表达式的结果.</li>
</ul>
<p>一组可被 <code>seq</code> (即seq可以为其生成有效值的类型)包括</p>
<ul>
<li>所有Clojure集合类型</li>
<li>所有Java集合(如java.util)</li>
<li>所有Java maps</li>
<li>所有 <code>java.lang.CharSequences</code> , 包括字符串.</li>
<li>任意实现了 <code>java.lang.Iterable</code> 的类型</li>
<li>Arrays</li>
<li>nil(Java方法返回null)</li>
<li>所有Clojure的 <code>clojure.lang.Seqable</code> 接口的实现</li>
</ul>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">seq </span><span class="s">&#34;Clojure&#34;</span><span class="p">)</span>
<span class="c1">;= (\C \l \o \j \u \r \e)</span>

<span class="p">(</span><span class="nb">seq </span><span class="p">{</span><span class="ss">:a</span> <span class="mi">5</span> <span class="ss">:b</span> <span class="mi">6</span><span class="p">})</span>
<span class="c1">;= ([:a 5] [:b 6])</span>

<span class="p">(</span><span class="nb">seq </span><span class="p">(</span><span class="nf">java.util.ArrayList.</span> <span class="p">(</span><span class="nb">range </span><span class="mi">5</span><span class="p">)))</span>
<span class="c1">;= (0 1 2 3 4)</span>

<span class="p">(</span><span class="nb">seq </span><span class="p">(</span><span class="nb">into-array </span><span class="p">[</span><span class="s">&#34;Clojure&#34;</span> <span class="s">&#34;Programming&#34;</span><span class="p">]))</span>
<span class="c1">;= (&#34;Clojure&#34; &#34;Programming&#34;)</span>

<span class="p">(</span><span class="nb">seq </span><span class="p">[])</span>
<span class="c1">;= nil</span>

<span class="p">(</span><span class="nb">seq </span><span class="nv">nil</span><span class="p">)</span>
<span class="c1">;= nil</span>
</code></pre></td></tr></table>
</div>
</div><p><code>nil</code> 或者所有空集合组成的序列都是 <code>nil</code> .</p>
<p>Clojure标准库包含了许多操作和生成序列的函数.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">first </span><span class="s">&#34;Clojure&#34;</span><span class="p">)</span>
<span class="c1">;= \C</span>
<span class="p">(</span><span class="nb">rest </span><span class="s">&#34;Clojure&#34;</span><span class="p">)</span>
<span class="c1">;= (\l \o \j \u \r \e)</span>
<span class="p">(</span><span class="nb">next </span><span class="s">&#34;Clojure&#34;</span><span class="p">)</span>
<span class="c1">;= (\l \o \j \u \r \e)</span>
</code></pre></td></tr></table>
</div>
</div><p><code>rest</code> 和 <code>next</code> 大多数情况下处理结果是相同的, 但在处理零个或一个值的序列时有所不同.</p>
<ul>
<li><code>rest</code> 总是返回空序列.</li>
<li>如果为空序列, <code>next</code> 回返回nil.</li>
</ul>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">rest </span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="c1">;= ()</span>
<span class="p">(</span><span class="nb">next </span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="c1">;= nil</span>

<span class="p">(</span><span class="nb">rest </span><span class="nv">nil</span><span class="p">)</span>
<span class="c1">;= ()</span>
<span class="p">(</span><span class="nb">next </span><span class="nv">nil</span><span class="p">)</span>
<span class="c1">;= nil</span>
</code></pre></td></tr></table>
</div>
</div><p>对于值x来说这个条件永远为真, 这种细小的区别, 就可以实现惰性序列.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">next </span><span class="nv">x</span><span class="p">)</span>
   <span class="p">(</span><span class="nb">seq </span><span class="p">(</span><span class="nb">rest </span><span class="nv">x</span><span class="p">)))</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<ul>
<li>
<p>序列不是迭代器</p>
<p><code>(range 3)</code> 返回的序列是不可变, 持久的集合. 看上去像是x把序列的值从迭代器中取出来.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">x</span> <span class="p">(</span><span class="nb">range </span><span class="mi">3</span><span class="p">)]</span>
  <span class="p">(</span><span class="nb">println </span><span class="nv">x</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>特别是，我们可以将函数映射到seq之上，而不影响它或它的源值、它的任何“后代”或其父值。这些特性没有一个是由可变状态迭代器和生成器共享的，它们不能被选中，不能安全地用作其他迭代器的基础，并且一旦使用，就不能再使用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">r</span> <span class="p">(</span><span class="nb">range </span><span class="mi">3</span><span class="p">)</span>
      <span class="nv">rst</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">r</span><span class="p">)]</span>
  <span class="p">(</span><span class="nb">prn </span><span class="p">(</span><span class="nb">map str </span><span class="nv">rst</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">prn </span><span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nb">+ </span><span class="mi">100</span> <span class="nv">%</span><span class="p">)</span> <span class="nv">r</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">prn </span><span class="p">(</span><span class="nb">conj </span><span class="nv">r</span> <span class="mi">-1</span><span class="p">)</span> <span class="p">(</span><span class="nb">conj </span><span class="nv">rst</span> <span class="mi">42</span><span class="p">)))</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>序列不是列表</p>
<p>序列和列表非常类似, 它们要么是空的, 要么由一个头部和一个本身就是序列的尾部组成.</p>
<p>此外, 列表就是它们自身的序列. 然而, 它们在一些重要方面有很大的不同</p>
<ul>
<li>获取一个 <code>seq</code> 的长度是有代价的.</li>
<li>序列中的内容可能被延迟计算, 只有访问涉及的值时候才实际计算.</li>
<li>为延迟序列生成值的计算可以选择生成这些值的无限级数, 从而使序列可能是无限的, 因此是不可数的.</li>
</ul>
<p>相反的, lists记录它们的长度, 因此获得lists长度数量的代价很小.</p>
<p>因此获取 <code>seq</code> 计数的唯一方法是强制对其进行完整遍历. 以下是 <code>seq</code> 和 <code>lists</code> 计数时间的区别.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">s</span> <span class="p">(</span><span class="nb">range </span><span class="mi">1</span><span class="nv">e6</span><span class="p">)]</span>
  <span class="p">(</span><span class="nb">time </span><span class="p">(</span><span class="nb">count </span><span class="nv">s</span><span class="p">)))</span>
<span class="c1">;= &#34;Elapsed time: 129.8121 msecs&#34;</span>
<span class="c1">;= 1000000</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">s</span> <span class="p">(</span><span class="nb">apply list </span><span class="p">(</span><span class="nb">range </span><span class="mi">1</span><span class="nv">e6</span><span class="p">))]</span>
  <span class="p">(</span><span class="nb">time </span><span class="p">(</span><span class="nb">count </span><span class="nv">s</span><span class="p">)))</span>
<span class="c1">;= &#34;Elapsed time: 0.0296 msecs&#34;</span>
<span class="c1">;= 1000000</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>创建序列</p>
<p>一个序列是由集合生产的, 不管是显式指定 <code>seq</code> 或者通过另一个函数(如map)隐式地对其参数调用 <code>seq</code> .</p>
<p>然而, 有两种方式创建序列</p>
<ul>
<li><code>cons</code></li>
<li><code>list*</code></li>
</ul>
<p><code>cons</code> 接受两个参数, 一个作为新seq头部的值, 一个是作为seq尾部的集合.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">cons </span><span class="mi">0</span> <span class="p">(</span><span class="nb">range </span><span class="mi">1</span> <span class="mi">5</span><span class="p">))</span>
<span class="c1">;= (0 1 2 3 4)</span>
</code></pre></td></tr></table>
</div>
</div><p>无论集合的具体类型如何, 都可以假装将 <code>cons</code> 看作尾集合序列, 从而将自己和 <code>conj</code> 区分开来.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">cons </span><span class="ss">:a</span> <span class="p">[</span><span class="ss">:b</span> <span class="ss">:c</span> <span class="ss">:d</span><span class="p">])</span>
<span class="c1">;= (:a :b :c :d)</span>
</code></pre></td></tr></table>
</div>
</div><p><code>list*</code> 类似于使用任意数量的开始值, 随后跟着一个序列的辅助函数.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">cons </span><span class="mi">0</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">1</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">2</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">3</span> <span class="p">(</span><span class="nb">range </span><span class="mi">4</span> <span class="mi">10</span><span class="p">)))))</span>
<span class="c1">;= (0 1 2 3 4 5 6 7 8 9)</span>

<span class="c1">;; 等价于</span>

<span class="p">(</span><span class="nb">list* </span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="p">(</span><span class="nb">range </span><span class="mi">4</span> <span class="mi">10</span><span class="p">))</span>
<span class="c1">;= (0 1 2 3 4 5 6 7 8 9)</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>惰性序列</p>
<p>序列的内容可能被延迟地求值, 这种情况下,当消费者需要访问它们时, 值按需执行的计算的结果.</p>
<p>每次这样的值总是有且只有一次被求值.</p>
<p>访问惰性序列的过程称为变现.</p>
<p>当所有在惰性序列的值被计算完毕, 就称该序列已经被完全变现了.</p>
<p>可以使用 <code>lazy-seq</code> 宏来创建一个惰性序列, 该宏接受任意对序列值求值的表达式.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">lazy-seq</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>
<span class="c1">;= (1 2 3)</span>
</code></pre></td></tr></table>
</div>
</div><p>序列可以延迟地生成一系列随机整数.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">random-ints</span>
  <span class="s">&#34;Returns a lazy seq of random integers in the range[0,limit).&#34;</span>
  <span class="p">[</span><span class="nv">limit</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">lazy-seq</span>
   <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">rand-int </span><span class="nv">limit</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">random-ints</span> <span class="nv">limit</span><span class="p">))))</span>

<span class="c1">;= (take 10 (random-ints 50))</span>
<span class="c1">;= (22 36 42 32 5 30 42 5 15 29)</span>
</code></pre></td></tr></table>
</div>
</div><p>这里显示了它的全部内容, 因为序列会强制变现它的内容.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">random-ints</span>
  <span class="p">[</span><span class="nv">limit</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">lazy-seq</span>
   <span class="p">(</span><span class="nb">println </span><span class="s">&#34;realizing random number&#34;</span><span class="p">)</span>
   <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">rand-int </span><span class="nv">limit</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">random-ints</span> <span class="nv">limit</span><span class="p">))))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">rands</span> <span class="p">(</span><span class="nb">take </span><span class="mi">10</span> <span class="p">(</span><span class="nf">random-ints</span> <span class="mi">50</span><span class="p">)))</span>
<span class="c1">;= #&#39;chapter3.core/rands</span>
<span class="p">(</span><span class="nb">first </span><span class="nv">rands</span><span class="p">)</span>
<span class="c1">;= realizing random number</span>
<span class="c1">;= 3</span>

<span class="p">(</span><span class="nb">nth </span><span class="nv">rands</span> <span class="mi">3</span><span class="p">)</span>
<span class="c1">;= realizing random number</span>
<span class="c1">;= realizing random number</span>
<span class="c1">;= realizing random number</span>
<span class="c1">;= 2</span>

<span class="p">(</span><span class="nb">count </span><span class="nv">rands</span><span class="p">)</span>
<span class="c1">;= realizing random number</span>
<span class="c1">;= realizing random number</span>
<span class="c1">;= realizing random number</span>
<span class="c1">;= realizing random number</span>
<span class="c1">;= realizing random number</span>
<span class="c1">;= realizing random number</span>
<span class="c1">;= 10</span>
<span class="p">(</span><span class="nb">count </span><span class="nv">rands</span><span class="p">)</span>
<span class="c1">;= 10</span>
</code></pre></td></tr></table>
</div>
</div><p>延迟序列的头是一个具体的值, 它的尾部完全是一个由挂起在函数中的计算定义的, 这个函数是 <code>lazy-seq</code> 从它提供的表达式创建的, 我们访问它对应值时不会调用它.</p>
<p>上面这点指出了 <code>cons</code> 和 <code>list*</code> 的优点</p>
<ul>
<li><code>lazy-seq</code> 创建的函数不会强制求它们作为最终参数提供的(潜在的惰性)序列的值.</li>
<li>这使得上面的函数称为惰性seq的关键辅助. 常见的模式是返回带有一个或多个具体 <code>seq</code> 值的 <code>cons</code> 或 <code>list*</code> 调用结果, 紧随一个被挂起的调用或计算生成的其余惰性序列.</li>
</ul>
<p><code>random-ints</code> 设计很糟糕, 过于复杂的功能实现. 可以通过几个Clojure标准库函数组合实现该功能.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">repeatedly</span> <span class="mi">10</span> <span class="p">(</span><span class="nb">partial rand-int </span><span class="mi">50</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>有些情况下, 我们要小心地最小化强制变现惰性序列的程度. 如 <code>next</code> 会检查非空尾序列. 这个检查必然会强制变现非空尾序列的头部.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">x</span> <span class="p">(</span><span class="nb">next </span><span class="p">(</span><span class="nf">random-ints</span> <span class="mi">50</span><span class="p">)))</span>
<span class="c1">;= realizing random number</span>
<span class="c1">;= realizing random number</span>
<span class="c1">;= #&#39;chapter3.core/x</span>
</code></pre></td></tr></table>
</div>
</div><p>相反的, <code>rest</code> 会返回序列的尾部, 从而避免了变现它的头部以此实现最大化惰性.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">x</span> <span class="p">(</span><span class="nb">rest </span><span class="p">(</span><span class="nf">random-ints</span> <span class="mi">50</span><span class="p">)))</span>
<span class="c1">;= realizing random number</span>
<span class="c1">;= #&#39;chapter3.core/x</span>
</code></pre></td></tr></table>
</div>
</div><p>序列的解构通常使用 <code>next</code> 而不是 <code>rest</code> . 因此解构一个惰性序列会永远变现尾序列的头.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">let </span><span class="p">[[</span><span class="nv">x</span> <span class="o">&amp;</span> <span class="nv">rest</span><span class="p">]</span> <span class="p">(</span><span class="nf">random-ints</span> <span class="mi">50</span><span class="p">)])</span>
<span class="c1">;= realizing random number</span>
<span class="c1">;= realizing random number</span>
<span class="c1">;= nil</span>
</code></pre></td></tr></table>
</div>
</div><p>完全变现惰性序列需要花费一定的时间, 在这种情况下:</p>
<ul>
<li>如果希望保留序列的内容, 应该使用 <code>doall</code></li>
<li>如果希望在生成序列中的每个值时处理内容, 使用 <code>dorun</code> .</li>
</ul>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">dorun </span><span class="p">(</span><span class="nb">take </span><span class="mi">5</span> <span class="p">(</span><span class="nf">random-ints</span> <span class="mi">50</span><span class="p">)))</span>
<span class="c1">;= realizing random number</span>
<span class="c1">;= realizing random number</span>
<span class="c1">;= realizing random number</span>
<span class="c1">;= realizing random number</span>
<span class="c1">;= realizing random number</span>
<span class="c1">;= nil</span>
</code></pre></td></tr></table>
</div>
</div><p>不保留惰性求值的内容似乎有点浪费, 但如果惰性序列计算有副作用可能会非常有用, 而且你只关心副作用是否发生.</p>
<p>通常地, 通过 <code>seq</code> 进行操作的函数的文档明确说明了它们是生成惰性 <code>seq</code> 还是强制变现它们.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">doc </span><span class="nv">iterate</span><span class="p">)</span>
<span class="c1">; -------------------------</span>
<span class="c1">; clojure.core/iterate</span>
<span class="c1">; ([f x])</span>
<span class="c1">; Returns a lazy sequence of x, (f x), (f (f x)) etc.</span>
<span class="c1">; f must be free of side-effects</span>
<span class="p">(</span><span class="nb">doc </span><span class="nv">reverse</span><span class="p">)</span>
<span class="c1">; -------------------------</span>
<span class="c1">; clojure.core/reverse</span>
<span class="c1">; ([coll])</span>
<span class="c1">; Returns a seq of the items in coll in reverse order. Not lazy.</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>定义了延迟序列化的代码应该尽量减少副作用</p>
<p>Clojure惰性序列仅限于序列.</p>
<p>惰性序列允许Clojure透明处理不适合内存的大数据集, 并以更统一, 更简洁的流水线方式表示算法. 这种情况下, 序列可以被看作短暂的计算媒介, 而不是集合.</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>头部持久化</p>
<p>Clojure的惰性序列会持久化, 一旦计算到某个值, 该值被持久化, 就会被避免垃圾回收. 久而久之, 容易造成内存溢出错误.</p>
<p><code>split-with</code> 函数, 接受一个谓词和一个序列值. 然后返回一个包含两个惰性序列的向量.</p>
<ul>
<li>满足谓词的前缀</li>
<li>从不满足谓词的第一项开始的后缀.</li>
</ul>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">split-with neg? </span><span class="p">(</span><span class="nb">range </span><span class="mi">-5</span> <span class="mi">5</span><span class="p">))</span>
<span class="c1">;= [(-5 -4 -3 -2 -1) (0 1 2 3 4)]</span>
</code></pre></td></tr></table>
</div>
</div><p>假设使用 <code>split-with</code> 的前缀序列很小, 后缀序列很大, 如果保留对前缀序列的引用, 即使对后缀处理是延时的, 序列中的所有值也会被保留.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">let </span><span class="p">[[</span><span class="nv">t</span> <span class="nv">d</span><span class="p">]</span> <span class="p">(</span><span class="nb">split-with </span><span class="o">#</span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">%</span> <span class="mi">12</span><span class="p">)</span> <span class="p">(</span><span class="nb">range </span><span class="mi">1</span><span class="nv">e8</span><span class="p">))]</span>
  <span class="p">[(</span><span class="nb">count </span><span class="nv">d</span><span class="p">)</span> <span class="p">(</span><span class="nb">count </span><span class="nv">t</span><span class="p">)])</span>
<span class="c1">;= OutOfMemoryError GC overhead limit exceeded  clojure.lang.Range.next (Range.java:143)</span>
</code></pre></td></tr></table>
</div>
</div><p>修改后的代码避免内存溢出, 由于上例在计算大的后缀序列时候, 序列里的每一个元素都被持久化, 没有被垃圾回收, 所以造成内存溢出. 该例只持久化前缀序列的元素, 数量是12.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">let </span><span class="p">[[</span><span class="nv">t</span> <span class="nv">d</span><span class="p">]</span> <span class="p">(</span><span class="nb">split-with </span><span class="o">#</span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">%</span> <span class="mi">12</span><span class="p">)</span> <span class="p">(</span><span class="nb">range </span><span class="mi">1</span><span class="nv">e8</span><span class="p">))]</span>
  <span class="p">[(</span><span class="nb">count </span><span class="nv">t</span><span class="p">)</span> <span class="p">(</span><span class="nb">count </span><span class="nv">d</span><span class="p">)])</span>
<span class="c1">;= [12 99999988]</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h4 id="关联">关联</h4>
<p>关联抽象由以某种方式链接键和值的数据进行结构共享. 它提供了以下四个操作</p>
<ul>
<li><code>assoc</code> , 在给定键与值组成的集合中建立新关联.</li>
<li><code>dissoc</code> , 从集合中删除给定键的关联.</li>
<li><code>get</code> , 查出集合中特定键的值.</li>
<li><code>container?</code> , 只有当集合中包含给定键对应的值时, 该谓词返回真.</li>
</ul>
<p>关联系列函数更适合Clojure抽象数据结构的Map.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">m</span> <span class="p">{</span><span class="ss">:a</span> <span class="mi">1</span>, <span class="ss">:b</span> <span class="mi">2</span>, <span class="ss">:c</span> <span class="mi">3</span><span class="p">})</span>

<span class="p">(</span><span class="nb">get </span><span class="nv">m</span> <span class="ss">:b</span><span class="p">)</span>

<span class="p">(</span><span class="nb">get </span><span class="nv">m</span> <span class="ss">:d</span><span class="p">)</span>

<span class="p">(</span><span class="nb">get </span><span class="nv">m</span> <span class="ss">:d</span> <span class="s">&#34;not-found&#34;</span><span class="p">)</span>

<span class="p">(</span><span class="nb">assoc </span><span class="nv">m</span> <span class="ss">:d</span> <span class="mi">4</span><span class="p">)</span>

<span class="p">(</span><span class="nb">dissoc </span><span class="nv">m</span> <span class="ss">:b</span><span class="p">)</span>

<span class="p">(</span><span class="nb">assoc </span><span class="nv">m</span>
       <span class="ss">:x</span> <span class="mi">4</span>
       <span class="ss">:y</span> <span class="mi">5</span>
       <span class="ss">:z</span> <span class="mi">6</span><span class="p">)</span>

<span class="p">(</span><span class="nb">dissoc </span><span class="nv">m</span> <span class="ss">:a</span> <span class="ss">:c</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p><code>get</code> 和 <code>assoc</code> 同样支持向量. 映射和向量都是关联结合, 向量关联的是索引和值.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">v</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>

<span class="p">(</span><span class="nb">get </span><span class="nv">v</span> <span class="mi">1</span><span class="p">)</span>

<span class="p">(</span><span class="nb">get </span><span class="nv">v</span> <span class="mi">10</span><span class="p">)</span>

<span class="p">(</span><span class="nb">get </span><span class="nv">v</span> <span class="mi">10</span> <span class="s">&#34;not-found&#34;</span><span class="p">)</span>

<span class="p">(</span><span class="nb">assoc </span><span class="nv">v</span>
       <span class="mi">1</span> <span class="mi">4</span>
       <span class="mi">0</span> <span class="mi">-12</span>
       <span class="mi">2</span> <span class="ss">:p</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p><code>assoc</code> 添加元素到向量中, 需要知道索引位置.</p>
<p><code>get</code> 可以用于集合, 其中需要显示指定&quot;键(集合中的值)&ldquo;的内容.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">get </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">}</span> <span class="mi">2</span><span class="p">)</span>

<span class="p">(</span><span class="nb">get </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">}</span> <span class="mi">4</span><span class="p">)</span>

<span class="p">(</span><span class="nb">get </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">}</span> <span class="mi">4</span> <span class="s">&#34;not-found&#34;</span><span class="p">)</span>

<span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">get </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">}</span> <span class="mi">2</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">println </span><span class="s">&#34;it contains `2`!&#34;</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p><code>contains?</code> 是一个谓词, 只有集合中包含给定键的关联值时返回true. 参数为键.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">contains? </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span> <span class="mi">0</span><span class="p">)</span>

<span class="p">(</span><span class="nb">contains? </span><span class="p">{</span><span class="ss">:a</span> <span class="mi">5</span> <span class="ss">:b</span> <span class="mi">6</span><span class="p">}</span> <span class="ss">:b</span><span class="p">)</span>

<span class="p">(</span><span class="nb">contains? </span><span class="p">{</span><span class="ss">:a</span> <span class="mi">5</span> <span class="ss">:b</span> <span class="mi">6</span><span class="p">}</span> <span class="mi">42</span><span class="p">)</span>

<span class="p">(</span><span class="nb">contains? </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">}</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1">;;contains?可能容易让人造成误解,因为传入的参数是键</span>
<span class="p">(</span><span class="nb">contains? </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span> <span class="mi">3</span><span class="p">)</span>
<span class="c1">;= false</span>
<span class="p">(</span><span class="nb">contains? </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1">;= true</span>
<span class="p">(</span><span class="nb">contains? </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span> <span class="mi">0</span><span class="p">)</span>
<span class="c1">;= true</span>
</code></pre></td></tr></table>
</div>
</div><p><code>get</code> 和 <code>contains</code> 也可以工作在Java的maps上, 字符串和数组上.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">get </span><span class="s">&#34;Clojure&#34;</span> <span class="mi">3</span><span class="p">)</span>

<span class="p">(</span><span class="nb">contains? </span><span class="p">(</span><span class="nf">java.util.HashMap.</span><span class="p">)</span> <span class="s">&#34;not-there&#34;</span><span class="p">)</span>

<span class="p">(</span><span class="nb">get </span><span class="p">(</span><span class="nb">into-array </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<ul>
<li>
<p>注意nil值</p>
<p>当集合没有对应的key条目时, 同事没有提供默认值, <code>get</code> 会返回 <code>nil</code> .</p>
<p>然而 <code>nil</code> 是一个有效值, 如果给定的键对应的值是 <code>nil</code> , 它同样会返回.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">get </span><span class="p">{</span><span class="ss">:ethe1</span> <span class="nv">nil</span><span class="p">}</span> <span class="ss">:lucy</span><span class="p">)</span>

<span class="p">(</span><span class="nb">get </span><span class="p">{</span><span class="ss">:ethe1</span> <span class="nv">nil</span><span class="p">}</span> <span class="ss">:ethe1</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p><code>find</code> 函数类似于 <code>get</code> 函数, 对应的键存在关联的值时, 它会返回整个条目, 否则, 返回 <code>nil</code> .</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">find </span><span class="p">{</span><span class="ss">:ethe1</span> <span class="nv">nil</span><span class="p">}</span> <span class="ss">:lucy</span><span class="p">)</span>
<span class="c1">;= nil</span>
<span class="p">(</span><span class="nb">find </span><span class="p">{</span><span class="ss">:ethe1</span> <span class="nv">nil</span><span class="p">}</span> <span class="ss">:ethe1</span><span class="p">)</span>
<span class="c1">;= [:ethe1 nil]</span>
</code></pre></td></tr></table>
</div>
</div><p><code>find</code> 对解构和条件形式(if-let或when-let)的支持非常好.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">if-let </span><span class="p">[</span><span class="nv">e</span> <span class="p">(</span><span class="nb">find </span><span class="p">{</span><span class="ss">:a</span> <span class="mi">5</span> <span class="ss">:b</span> <span class="mi">6</span><span class="p">}</span> <span class="ss">:a</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">format</span> <span class="s">&#34;found %s =&gt; %s&#34;</span> <span class="p">(</span><span class="nb">key </span><span class="nv">e</span><span class="p">)(</span><span class="nb">val </span><span class="nv">e</span><span class="p">))</span>
  <span class="s">&#34;not found&#34;</span><span class="p">)</span>

<span class="p">(</span><span class="nb">if-let </span><span class="p">[[</span><span class="nv">k</span> <span class="nv">v</span><span class="p">]</span> <span class="p">(</span><span class="nb">find </span><span class="p">{</span><span class="ss">:a</span> <span class="mi">5</span> <span class="ss">:b</span> <span class="mi">6</span><span class="p">}</span> <span class="ss">:a</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">format</span> <span class="s">&#34;found %s =&gt; %s&#34;</span> <span class="nv">k</span> <span class="nv">v</span><span class="p">)</span>
  <span class="s">&#34;not found&#34;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h4 id="索引">索引</h4>
<p><code>nth</code> 函数是 <code>get</code> 的一个特例, 它们在处理越界索引的方式有所不同. <code>nth</code> 会抛出异常, <code>get</code> 会返回 <code>nil</code> .</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">nth </span><span class="p">[</span><span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">]</span> <span class="mi">2</span><span class="p">)</span>

<span class="p">(</span><span class="nb">get </span><span class="p">[</span><span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">]</span> <span class="mi">2</span><span class="p">)</span>

<span class="p">(</span><span class="nb">nth </span><span class="p">[</span><span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">]</span> <span class="mi">3</span><span class="p">)</span>

<span class="p">(</span><span class="nb">get </span><span class="p">[</span><span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">]</span> <span class="mi">3</span><span class="p">)</span>

<span class="p">(</span><span class="nb">nth </span><span class="p">[</span><span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">]</span> <span class="mi">-1</span><span class="p">)</span>

<span class="p">(</span><span class="nb">get </span><span class="p">[</span><span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">]</span> <span class="mi">-1</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>如果提供了默认的返回值, <code>nth</code> 和 <code>get</code> 的语义相同.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">nth </span><span class="p">[</span><span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">]</span> <span class="mi">-1</span> <span class="ss">:not-found</span><span class="p">)</span>

<span class="p">(</span><span class="nb">get </span><span class="p">[</span><span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">]</span> <span class="mi">-1</span> <span class="ss">:not-found</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p><code>nth</code> 和 <code>get</code> 有不同的含义</p>
<ul>
<li><code>nth</code> 只能工作在数字类型的索引, <code>get</code> 能适用在许多关联类型上, 更加通用.</li>
<li><code>get</code> 更有弹性, 当索引对应的值不存在, 它返回 <code>nil</code>. <code>nth</code> 直接抛出异常.</li>
</ul>
<h4 id="栈">栈</h4>
<p>栈是一种支持后进先出的数据结构.</p>
<p>Clojure没有区分栈数据结构, 但是有以下三个支持栈抽象操作函数</p>
<ul>
<li><code>conj</code> 往栈中添加元素.</li>
<li><code>pop</code> 弹出栈顶元素.</li>
<li><code>peek</code> 获取栈顶元素.</li>
</ul>
<p>所有的列表和向量都可以用作为栈.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">conj </span><span class="o">&#39;</span><span class="p">()</span> <span class="mi">1</span><span class="p">)</span>

<span class="p">(</span><span class="nb">conj </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">3</span><span class="p">)</span>

<span class="p">(</span><span class="nb">peek </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span><span class="p">))</span>

<span class="p">(</span><span class="nb">pop </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span><span class="p">))</span>

<span class="p">(</span><span class="nb">pop </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

<span class="p">(</span><span class="nb">conj </span><span class="p">[]</span> <span class="mi">1</span><span class="p">)</span>

<span class="p">(</span><span class="nb">conj </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">]</span> <span class="mi">3</span><span class="p">)</span>

<span class="p">(</span><span class="nb">peek </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>

<span class="p">(</span><span class="nb">pop </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>

<span class="p">(</span><span class="nb">pop </span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="集合">集合</h4>
<p><code>disj</code> 函数可以从集合中移除给定的集合.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">disj </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">}</span> <span class="mi">3</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Clojure 提供了操作集合的高等标准库函数, 在 <code>clojure.set</code> 包下.</p>
<h4 id="有序集合">有序集合</h4>
<p>参与排序抽象的集合保证了值将稳定的顺序维护.以下是获取所有或一个子集合的有序和反序序列.</p>
<ul>
<li><code>rseq</code> 返回反向顺序的集合, 保证该操作是常量时间.</li>
<li><code>subseq</code> 返回给定键范围中的子集合.</li>
<li><code>rsubseq</code> 返回给定键范围中的子集合, 顺序是反向顺序.</li>
</ul>
<p>只有映射和集合有可用于排序的变体(数据结构).</p>
<ul>
<li><code>sorted-map</code></li>
<li><code>sorted-set</code></li>
<li><code>sorted-map-by</code></li>
<li><code>sorted-set-by</code></li>
</ul>
<p>可以使用任何抽象函数去查找有序集合</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">sm</span> <span class="p">(</span><span class="nb">sorted-map </span><span class="ss">:z</span> <span class="mi">5</span> <span class="ss">:x</span> <span class="mi">9</span> <span class="ss">:y</span> <span class="mi">0</span> <span class="ss">:b</span> <span class="mi">2</span> <span class="ss">:a</span> <span class="mi">3</span> <span class="ss">:c</span> <span class="mi">4</span><span class="p">))</span>

<span class="nv">sm</span>

<span class="p">(</span><span class="nb">rseq </span><span class="nv">sm</span><span class="p">)</span>

<span class="p">(</span><span class="nf">subseq</span> <span class="nv">sm</span> <span class="nb">&lt;= </span><span class="ss">:c</span><span class="p">)</span>

<span class="p">(</span><span class="nf">rsubseq</span> <span class="nv">sm</span> <span class="nb">&gt; </span><span class="ss">:b</span> <span class="nb">&lt;= </span><span class="ss">:y</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p><code>compare</code> 函数定义了默认的升序排序, 支持Clojure标量和顺序集合.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">compare</span> <span class="mi">2</span> <span class="mi">2</span><span class="p">)</span>

<span class="p">(</span><span class="nf">compare</span> <span class="s">&#34;ab&#34;</span> <span class="s">&#34;abc&#34;</span><span class="p">)</span>

<span class="p">(</span><span class="nf">compare</span> <span class="p">[</span><span class="s">&#34;a&#34;</span> <span class="s">&#34;b&#34;</span> <span class="s">&#34;c&#34;</span><span class="p">]</span> <span class="p">[</span><span class="s">&#34;a&#34;</span> <span class="s">&#34;b&#34;</span><span class="p">])</span>

<span class="p">(</span><span class="nf">compare</span> <span class="p">[</span><span class="s">&#34;a&#34;</span> <span class="mi">2</span><span class="p">]</span> <span class="p">[</span><span class="s">&#34;a&#34;</span> <span class="mi">2</span> <span class="mi">0</span><span class="p">])</span>
</code></pre></td></tr></table>
</div>
</div><p><code>compare</code> 支持任何实现了 <code>java.lang.Comparable</code> 接口的实现.</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>比较器和谓词定义排序规则</p>
<p>比较器接受两个参数</p>
<ul>
<li>如果第一个参数比第二个参数大, 返回正数.</li>
<li>如果第一个参数比第二个参数小, 返回负数.</li>
<li>如果第一个参数和第二个参数相同, 返回0.</li>
</ul>
<p>所有实现了 <code>java.util.Comparator</code> 的函数可以用作比较器.</p>
<p>比较函数可以直接传给排序集合工厂函数以及 <code>sort</code> 和 <code>sort-by</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">sort &lt; </span><span class="p">(</span><span class="nf">repeatedly</span> <span class="mi">10</span> <span class="o">#</span><span class="p">(</span><span class="nb">rand-int </span><span class="mi">100</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">sort-by first &gt; </span><span class="p">(</span><span class="nf">map-indexed</span> <span class="nb">vector </span><span class="s">&#34;Clojure&#34;</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p><code>comparator</code> 函数可以显式指定两个参数的谓词变成比较器函数.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">((</span><span class="nb">comparator </span><span class="nv">&lt;</span><span class="p">)</span> <span class="mi">1</span> <span class="mi">4</span><span class="p">)</span>

<span class="p">((</span><span class="nb">comparator </span><span class="nv">&lt;</span><span class="p">)</span> <span class="mi">4</span> <span class="mi">1</span><span class="p">)</span>

<span class="p">((</span><span class="nb">comparator </span><span class="nv">&lt;</span><span class="p">)</span> <span class="mi">4</span> <span class="mi">4</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p><code>sorted-map</code> 和 <code>sorted-set</code> 可以创建一个键根据默认的排序的映射和集合.</p>
<p><code>sorted-map-by</code> 和 <code>sorted-set-by</code> 可以接受两个参数的比较器来控制它们的排序规则.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">sorted-map-by </span><span class="nv">compare</span> <span class="ss">:z</span> <span class="mi">5</span> <span class="ss">:x</span> <span class="mi">9</span> <span class="ss">:y</span> <span class="mi">0</span> <span class="ss">:b</span> <span class="mi">2</span> <span class="ss">:a</span> <span class="mi">3</span> <span class="ss">:c</span> <span class="mi">4</span><span class="p">)</span>
<span class="c1">;= {:a 3, :b 2, :c 4, :x 9, :y 0, :z 5}</span>

<span class="p">(</span><span class="nb">sorted-map-by </span><span class="p">(</span><span class="nb">comp - </span><span class="nv">compare</span><span class="p">)</span> <span class="ss">:z</span> <span class="mi">5</span> <span class="ss">:x</span> <span class="mi">9</span> <span class="ss">:y</span> <span class="mi">0</span> <span class="ss">:b</span> <span class="mi">2</span> <span class="ss">:a</span> <span class="mi">3</span> <span class="ss">:c</span> <span class="mi">4</span><span class="p">)</span>
<span class="c1">;= {:z 5, :y 0, :x 9, :c 4, :b 2, :a 3}</span>
</code></pre></td></tr></table>
</div>
</div><p>注意的是排序顺序在已排序的映射和集合中定义了相等性.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">magntitude</span>
  <span class="p">[</span><span class="nv">x</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">-&gt; </span><span class="nv">x</span> <span class="nv">Math/log10</span> <span class="nv">Math/floor</span><span class="p">))</span>

<span class="c1">;; 返回指数的差</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">compare-magnitude</span>
  <span class="p">[</span><span class="nv">a</span> <span class="nv">b</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nf">magntitude</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nf">magntitude</span> <span class="nv">b</span><span class="p">)))</span>


<span class="p">((</span><span class="nb">comparator </span><span class="nv">compare-magnitude</span><span class="p">)</span> <span class="mi">10</span> <span class="mi">10000</span><span class="p">)</span>
<span class="c1">;= -1</span>

<span class="p">((</span><span class="nb">comparator </span><span class="nv">compare-magnitude</span><span class="p">)</span> <span class="mi">100</span> <span class="mi">10</span><span class="p">)</span>
<span class="c1">;= -1</span>

<span class="p">((</span><span class="nb">comparator </span><span class="nv">compare-magnitude</span><span class="p">)</span> <span class="mi">10</span> <span class="mi">75</span><span class="p">)</span>

<span class="p">(</span><span class="nf">sorted-set-by</span> <span class="nv">compare-magnitude</span> <span class="mi">10</span> <span class="mi">1000</span> <span class="mi">500</span><span class="p">)</span>
<span class="c1">;= #{10 500 1000}</span>

<span class="p">(</span><span class="nb">conj </span><span class="nv">*1</span> <span class="mi">600</span><span class="p">)</span>
<span class="c1">;= #{10 500 1000}</span>

<span class="p">(</span><span class="nb">disj </span><span class="nv">*1</span> <span class="mi">750</span><span class="p">)</span>
<span class="c1">;= #{10 1000}</span>

<span class="p">(</span><span class="nb">contains? </span><span class="nv">*1</span> <span class="mi">1239</span><span class="p">)</span>
<span class="c1">;= true</span>

<span class="p">(</span><span class="nf">sorted-set-by</span> <span class="nv">compare-magnitude</span> <span class="mi">10</span> <span class="mi">1000</span> <span class="mi">500</span> <span class="mi">670</span> <span class="mi">1239</span><span class="p">)</span>

<span class="p">(</span><span class="k">def </span><span class="nv">ss</span> <span class="nv">*1</span><span class="p">)</span>

<span class="p">(</span><span class="nf">subseq</span> <span class="nv">ss</span> <span class="nb">&gt; </span><span class="mi">500</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>其中 <code>*1</code> 表示绑定在repl线程里面最近一个变量. <code>*2</code> 和 <code>*3</code> 分别表示最近的第二个或第三个.</p>
<p>实现线性插值</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">interpolate</span>
  <span class="s">&#34;Takes a collection of points (as [x y] tuples), returning a function
</span><span class="s">   which is a liner interpolation between those points.&#34;</span>
  <span class="p">[</span><span class="nv">points</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">results</span> <span class="p">(</span><span class="nb">into </span><span class="p">(</span><span class="nf">sorted-map</span><span class="p">)</span> <span class="p">(</span><span class="nb">map </span><span class="nv">vec</span> <span class="nv">points</span><span class="p">))]</span>
    <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span>
      <span class="p">(</span><span class="k">let </span><span class="p">[[</span><span class="nv">xa</span> <span class="nv">ya</span><span class="p">]</span> <span class="p">(</span><span class="nb">first </span><span class="p">(</span><span class="nf">rsubseq</span> <span class="nv">results</span> <span class="nb">&lt;= </span><span class="nv">x</span><span class="p">))</span>
        <span class="p">[</span><span class="nv">xb</span> <span class="nv">yb</span><span class="p">]</span> <span class="p">(</span><span class="nb">first </span><span class="p">(</span><span class="nf">subseq</span> <span class="nv">results</span> <span class="nb">&gt; </span><span class="nv">x</span><span class="p">))]</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">and </span><span class="nv">xa</span> <span class="nv">xb</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">* </span><span class="nv">ya</span> <span class="p">(</span><span class="nb">- </span><span class="nv">xb</span> <span class="nv">x</span><span class="p">))</span> <span class="p">(</span><span class="nb">* </span><span class="nv">yb</span> <span class="p">(</span><span class="nb">- </span><span class="nv">x</span> <span class="nv">xa</span><span class="p">)))</span>
         <span class="p">(</span><span class="nb">- </span><span class="nv">xb</span> <span class="nv">xa</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">or </span><span class="nv">ya</span> <span class="nv">yb</span><span class="p">))))))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">f</span> <span class="p">(</span><span class="nf">interpolate</span> <span class="p">[[</span><span class="mi">0</span> <span class="mi">0</span><span class="p">]</span> <span class="p">[</span><span class="mi">10</span> <span class="mi">10</span><span class="p">]</span> <span class="p">[</span><span class="mi">15</span> <span class="mi">5</span><span class="p">]]))</span>

<span class="p">(</span><span class="nb">map </span><span class="nv">f</span> <span class="p">[</span><span class="mi">2</span> <span class="mi">10</span> <span class="mi">12</span><span class="p">])</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="访问集合">访问集合</h3>
<p>集合就是函数. Clojure的集合就像函数一样, 可以根据给定的键找到关联的值.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">get </span><span class="p">[</span><span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">]</span> <span class="mi">2</span><span class="p">)</span>

<span class="p">(</span><span class="nb">get </span><span class="p">{</span><span class="ss">:a</span> <span class="mi">5</span> <span class="ss">:b</span> <span class="mi">6</span><span class="p">}</span> <span class="ss">:b</span><span class="p">)</span>

<span class="p">(</span><span class="nb">get </span><span class="p">{</span><span class="ss">:a</span> <span class="mi">5</span> <span class="ss">:b</span> <span class="mi">6</span><span class="p">}</span> <span class="ss">:c</span> <span class="mi">7</span><span class="p">)</span>

<span class="p">(</span><span class="nb">get </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">}</span> <span class="mi">3</span><span class="p">)</span>

<span class="p">([</span><span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">]</span> <span class="mi">2</span><span class="p">)</span>

<span class="p">({</span><span class="ss">:a</span> <span class="mi">5</span> <span class="ss">:b</span> <span class="mi">6</span><span class="p">}</span> <span class="ss">:b</span><span class="p">)</span>

<span class="p">({</span><span class="ss">:a</span> <span class="mi">5</span> <span class="ss">:b</span> <span class="mi">6</span><span class="p">}</span> <span class="ss">:c</span> <span class="mi">7</span><span class="p">)</span>

<span class="p">(</span><span class="o">#</span><span class="p">{</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">}</span> <span class="mi">3</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>集合的键通常是函数. 由于函数位置上的值必须是含, 数字索引(向量)不能使用如下的方式.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">get </span><span class="p">{</span><span class="ss">:a</span> <span class="mi">5</span> <span class="ss">:b</span> <span class="mi">6</span><span class="p">}</span> <span class="ss">:b</span><span class="p">)</span>

<span class="p">(</span><span class="nb">get </span><span class="p">{</span><span class="ss">:a</span> <span class="mi">5</span> <span class="ss">:b</span> <span class="mi">6</span><span class="p">}</span> <span class="ss">:c</span> <span class="mi">7</span><span class="p">)</span>

<span class="p">(</span><span class="nb">get </span><span class="o">#</span><span class="p">{</span><span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">}</span> <span class="ss">:d</span><span class="p">)</span>

<span class="p">(</span><span class="ss">:b</span> <span class="p">{</span><span class="ss">:a</span> <span class="mi">5</span> <span class="ss">:b</span> <span class="mi">6</span><span class="p">})</span>

<span class="p">(</span><span class="ss">:c</span> <span class="p">{</span><span class="ss">:a</span> <span class="mi">5</span> <span class="ss">:b</span> <span class="mi">6</span><span class="p">}</span> <span class="mi">7</span><span class="p">)</span>

<span class="p">(</span><span class="ss">:d</span> <span class="o">#</span><span class="p">{</span><span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">})</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="习惯用法">习惯用法</h4>
<p>一般使用关键字或符号作为函数. 这个习惯用法最大的优点就是可以通常避免空指针异常. 因为关键字和符号在查找函数中用作为字面量.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">get-foo</span>
  <span class="p">[</span><span class="nv">map</span><span class="p">]</span>
  <span class="p">(</span><span class="ss">:foo</span> <span class="nv">map</span><span class="p">))</span>

<span class="p">(</span><span class="nf">get-foo</span> <span class="nv">nil</span><span class="p">)</span>
<span class="c1">;= nil</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">get-bar</span>
  <span class="p">[</span><span class="nv">map</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">map </span><span class="ss">:bar</span><span class="p">))</span>

<span class="p">(</span><span class="nf">get-bar</span> <span class="nv">nil</span><span class="p">)</span>
<span class="c1">;= NullPointerException   chapter3.core/get-bar (form-init4965669559165713516.clj:243)</span>
</code></pre></td></tr></table>
</div>
</div><p>因为集合有可能为 <code>nil</code> 集合, 集合作为查找函数时就容易抛出空指针异常.</p>
<p>如果集合有关键字或符号以外的键, 则必须使用集合或 <code>get</code> 或 <code>nth</code> 作为查找函数.</p>
<h4 id="集合和键集和高阶函数">集合和键集和高阶函数</h4>
<p>由于键集, 符号集, 集合都是函数, 使用它们作为高阶函数的输入是十分方便的.</p>
<p>获取所有客户的名字</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">map </span><span class="ss">:name</span> <span class="p">[{</span><span class="ss">:age</span> <span class="mi">21</span> <span class="ss">:name</span> <span class="s">&#34;David&#34;</span><span class="p">}</span>
	    <span class="p">{</span><span class="ss">:gender</span> <span class="ss">:f</span> <span class="ss">:name</span> <span class="s">&#34;Suzanne&#34;</span><span class="p">}</span>
	    <span class="p">{</span><span class="ss">:name</span> <span class="s">&#34;Sara&#34;</span> <span class="ss">:location</span> <span class="s">&#34;NYC&#34;</span><span class="p">}])</span>
<span class="c1">;= (&#34;David&#34; &#34;Suzanne&#34; &#34;Sara&#34;)</span>
</code></pre></td></tr></table>
</div>
</div><p><code>some</code> 查找满足所提供谓词的序列第一个值. 这里使用集合作为函数, 语法比较简洁.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">some </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">7</span><span class="p">}</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">2</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">])</span>
<span class="c1">;= nil</span>

<span class="p">(</span><span class="nb">some </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">7</span><span class="p">}</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">])</span>
<span class="c1">;= 3</span>
</code></pre></td></tr></table>
</div>
</div><p>在合适的时候使用集合或者关键字或者是符号, 并根据需要组合其他函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">filter </span><span class="ss">:age</span> <span class="p">[{</span><span class="ss">:age</span> <span class="mi">21</span> <span class="ss">:name</span> <span class="s">&#34;David&#34;</span><span class="p">}</span>
	      <span class="p">{</span><span class="ss">:gender</span> <span class="ss">:f</span> <span class="ss">:name</span> <span class="s">&#34;Suzanne&#34;</span><span class="p">}</span>
	      <span class="p">{</span><span class="ss">:name</span> <span class="s">&#34;Sara&#34;</span> <span class="ss">:location</span> <span class="s">&#34;NYC&#34;</span><span class="p">}])</span>
<span class="c1">;= ({:age 21, :name &#34;David&#34;})</span>

<span class="p">(</span><span class="nb">filter </span><span class="p">(</span><span class="nb">comp </span><span class="p">(</span><span class="nb">partial &lt;= </span><span class="mi">25</span><span class="p">)</span> <span class="ss">:age</span><span class="p">)</span> <span class="p">[{</span><span class="ss">:age</span> <span class="mi">21</span> <span class="ss">:name</span> <span class="s">&#34;David&#34;</span><span class="p">}</span>
			    <span class="p">{</span><span class="ss">:gender</span> <span class="ss">:f</span> <span class="ss">:name</span> <span class="s">&#34;Suzanne&#34;</span> <span class="ss">:age</span> <span class="mi">20</span><span class="p">}</span>
			    <span class="p">{</span><span class="ss">:name</span> <span class="s">&#34;Sara&#34;</span> <span class="ss">:location</span> <span class="s">&#34;NYC&#34;</span> <span class="ss">:age</span> <span class="mi">34</span><span class="p">}])</span>
<span class="c1">;= ({:name &#34;Sara&#34;, :location &#34;NYC&#34;, :age 34})</span>
</code></pre></td></tr></table>
</div>
</div><p><code>remove</code> 是 <code>filter</code> 的补集, 它是通过使用给定函数的补集来过滤给定集合来实现的.</p>
<p>查找给定值是否属于某个集合, 给定值有可能是 <code>nil</code> 或 <code>false</code> . 结果可能和预期不同.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">remove </span><span class="o">#</span><span class="p">{</span><span class="mi">5</span> <span class="mi">7</span><span class="p">}</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">false</span> <span class="p">(</span><span class="nb">range </span><span class="mi">10</span><span class="p">)))</span>
<span class="c1">;= (false 0 1 2 3 4 6 8 9)</span>

<span class="p">(</span><span class="nb">remove </span><span class="o">#</span><span class="p">{</span><span class="mi">5</span> <span class="mi">7</span> <span class="nv">false</span><span class="p">}</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">false</span> <span class="p">(</span><span class="nb">range </span><span class="mi">10</span><span class="p">)))</span>
<span class="c1">;= (false 0 1 2 3 4 6 8 9)</span>

<span class="p">(</span><span class="nb">remove </span><span class="p">(</span><span class="nb">partial contains? </span><span class="o">#</span><span class="p">{</span><span class="mi">5</span> <span class="mi">7</span> <span class="nv">false</span><span class="p">})</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">false</span> <span class="p">(</span><span class="nb">range </span><span class="mi">10</span><span class="p">)))</span>
<span class="c1">;= (0 1 2 3 4 6 8 9)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="数据结构类型">数据结构类型</h3>
<p>Clojure 提供了一些具体数据结构, 它们每一个满足各种抽象.</p>
<h4 id="列表">列表</h4>
<p>使用 <code>conj</code> 将新的值推到列表头部, 用 <code>pop</code> 或序列操作符 <code>rest</code> 去获取对子序列的引用, 不需要预先的head值.</p>
<p>列表随机访问的效率比较低, <code>nth</code> 在list上是线性时间. 在数组或者向量是常量时间.</p>
<p><code>get</code> 不支持列表, 因为这样做不符合 <code>get</code> 的子线性效率目标.</p>
<p><code>list</code> 接受一些值, 这些值会求值, 求值后的每个值都会变成列表的元素并返回列表.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">list </span><span class="mi">1</span> <span class="mi">2</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">2</span><span class="p">))</span>
<span class="c1">;= (1 2 3)</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="向量">向量</h4>
<p>向量随机访问效率比较高, 修改的成本比较高.</p>
<p>可以使用 <code>vector</code> 和 <code>vec</code> 创建向量. <code>vector</code> 类似于 <code>list</code> , 而 <code>vec</code> 接受单序列参数, 该序列包含了向量的所有内容</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">vector </span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>

<span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">range </span><span class="mi">5</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p><code>vector?</code> 谓词类似于 <code>list?</code> , 用来判断值是否是向量.</p>
<p>元组是向量的常用案例, 几个值组合在一起, 作为函数的返回值, 可以放在一个向量里面.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">euclidian-division</span>
  <span class="p">[</span><span class="nv">x</span> <span class="nv">y</span><span class="p">]</span>
  <span class="p">[(</span><span class="nb">quot </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">rem </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)])</span>

<span class="p">(</span><span class="nf">euclidian-division</span> <span class="mi">42</span> <span class="mi">8</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>元组可以使用在Clojure的解构机制中</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">let </span><span class="p">[[</span><span class="nv">q</span> <span class="nv">r</span><span class="p">]</span> <span class="p">(</span><span class="nf">euclidian-division</span> <span class="mi">53</span> <span class="mi">7</span><span class="p">)]</span>
  <span class="p">(</span><span class="nb">str </span><span class="s">&#34;53/7 = &#34;</span> <span class="nv">q</span> <span class="s">&#34; * 7 + &#34;</span> <span class="nv">r</span> <span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>元组建议在因此在库和模块内部而不是以API形式暴露, 原因如下</p>
<ul>
<li>元组不是自己录的. 你必须自己记录各个索引各自的角色.</li>
<li>元组是死板的, 即使不适合特定返回值的中间槽也必须提供值, 并不能以附加到其尾部以外的形式扩展元组.</li>
</ul>
<p>向量有两种使用方式</p>
<ul>
<li>对外(提供API)的向量是一个更好的列表.</li>
<li>对内(库或模块内部)的向量是一个元组.</li>
</ul>
<h4 id="集合">集合</h4>
<p><code>hash-set</code> 函数可以从给定的许多参数中创建一个无序的集合.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">hash-set </span><span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span> <span class="ss">:d</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p><code>set</code> 函数可以从给定的值集合中创建一个集合.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">set </span><span class="p">[</span><span class="mi">1</span> <span class="mi">6</span> <span class="mi">1</span> <span class="mi">8</span> <span class="mi">3</span> <span class="mi">7</span> <span class="mi">7</span><span class="p">])</span>
</code></pre></td></tr></table>
</div>
</div><p><code>set</code> 可以适用于任何可做序列的东西, 集合本身就是函数.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">apply str </span><span class="p">(</span><span class="nb">remove </span><span class="p">(</span><span class="nb">set </span><span class="s">&#34;aeiouy&#34;</span><span class="p">)</span> <span class="s">&#34;vowels are useless&#34;</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">numeric?</span> <span class="p">[</span><span class="nv">s</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">every? </span><span class="p">(</span><span class="nb">set </span><span class="s">&#34;0123456789&#34;</span><span class="p">)</span> <span class="nv">s</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="映射">映射</h4>
<p><code>hash-map</code> 可以创建无排序的映射, 它接受一些键/值对作为参数.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">hash-map </span><span class="ss">:a</span> <span class="mi">5</span> <span class="ss">:b</span> <span class="mi">6</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>当有一组键/值对, 而这些键值对没有分组为向量元组时, 通常和 <code>apply</code> 一起使用.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">apply hash-map </span><span class="p">[</span><span class="ss">:a</span> <span class="mi">5</span> <span class="ss">:b</span> <span class="mi">6</span><span class="p">])</span>
<span class="c1">;= {:b 6, :a 5}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>keys</code> 函数可以获取映射的键集. <code>vals</code> 函数可以获取映射的值集.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">playlist</span>
  <span class="p">[{</span><span class="ss">:title</span> <span class="s">&#34;Elephant&#34;</span>, <span class="ss">:artist</span> <span class="s">&#34;The Wihte Stripes&#34;</span>, <span class="ss">:year</span> <span class="mi">2003</span><span class="p">}</span>
   <span class="p">{</span><span class="ss">:title</span> <span class="s">&#34;Helioself&#34;</span>, <span class="ss">:artist</span> <span class="s">&#34;Papas Fritas&#34;</span>, <span class="ss">:year</span> <span class="mi">1997</span><span class="p">}</span>
   <span class="p">{</span><span class="ss">:title</span> <span class="s">&#34;Stories from the City, Stories from the Sea&#34;</span>,
    <span class="ss">:artist</span> <span class="s">&#34;PJ Harvey&#34;</span>, <span class="ss">:year</span> <span class="mi">2000</span><span class="p">}</span>
   <span class="p">{</span><span class="ss">:title</span> <span class="s">&#34;Buildings and Grounds&#34;</span>, <span class="ss">:artist</span> <span class="s">&#34;Papas Fritas&#34;</span>, <span class="ss">:year</span> <span class="mi">2000</span><span class="p">}</span>
   <span class="p">{</span><span class="ss">:title</span> <span class="s">&#34;Zen Rodeo&#34;</span>, <span class="ss">:artist</span> <span class="s">&#34;Mardi Gras BB&#34;</span>, <span class="ss">:year</span> <span class="mi">2002</span><span class="p">}])</span>

<span class="p">(</span><span class="nb">map </span><span class="ss">:title</span> <span class="nv">playlist</span><span class="p">)</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">summarize</span> <span class="p">[{</span><span class="ss">:keys</span> <span class="p">[</span><span class="nv">title</span> <span class="nv">artist</span> <span class="nv">year</span><span class="p">]}]</span>
  <span class="p">(</span><span class="nb">str </span><span class="nv">title</span> <span class="s">&#34; / &#34;</span> <span class="nv">artist</span> <span class="s">&#34; / &#34;</span> <span class="nv">year</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p><code>group-by</code> 函数可以用在根据键函数划分集合.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">group-by</span> <span class="o">#</span><span class="p">(</span><span class="nb">rem </span><span class="nv">%</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nb">range </span><span class="mi">10</span><span class="p">))</span>
<span class="c1">;= {0 [0 3 6 9], 1 [1 4 7], 2 [2 5 8]}</span>

<span class="p">(</span><span class="nf">group-by</span> <span class="ss">:artist</span> <span class="nv">playlist</span><span class="p">)</span>
<span class="o">#</span><span class="nv">_</span><span class="p">{</span><span class="s">&#34;The Wihte Stripes&#34;</span>
 <span class="p">[{</span><span class="ss">:title</span> <span class="s">&#34;Elephant&#34;</span>, <span class="ss">:artist</span> <span class="s">&#34;The Wihte Stripes&#34;</span>, <span class="ss">:year</span> <span class="mi">2003</span><span class="p">}]</span>,
 <span class="s">&#34;Papas Fritas&#34;</span>
 <span class="p">[{</span><span class="ss">:title</span> <span class="s">&#34;Helioself&#34;</span>, <span class="ss">:artist</span> <span class="s">&#34;Papas Fritas&#34;</span>, <span class="ss">:year</span> <span class="mi">1997</span><span class="p">}</span>
  <span class="p">{</span><span class="ss">:title</span> <span class="s">&#34;Buildings and Grounds&#34;</span>, <span class="ss">:artist</span> <span class="s">&#34;Papas Fritas&#34;</span>, <span class="ss">:year</span> <span class="mi">2000</span><span class="p">}]</span>,
 <span class="s">&#34;PJ Harvey&#34;</span>
 <span class="p">[{</span><span class="ss">:title</span> <span class="s">&#34;Stories from the City, Stories from the Sea&#34;</span>,
   <span class="ss">:artist</span> <span class="s">&#34;PJ Harvey&#34;</span>,
   <span class="ss">:year</span> <span class="mi">2000</span><span class="p">}]</span>,
 <span class="s">&#34;Mardi Gras BB&#34;</span> <span class="p">[{</span><span class="ss">:title</span> <span class="s">&#34;Zen Rodeo&#34;</span>, <span class="ss">:artist</span> <span class="s">&#34;Mardi Gras BB&#34;</span>, <span class="ss">:year</span> <span class="mi">2002</span><span class="p">}]}</span>
</code></pre></td></tr></table>
</div>
</div><p>可以使用 <code>group-by</code> 计算给定键的总结, 而不是返回这些项的向量.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">into </span><span class="p">{}</span> <span class="p">(</span><span class="nb">for </span><span class="p">[[</span><span class="nv">k</span> <span class="nv">v</span><span class="p">]</span> <span class="p">(</span><span class="nf">group-by</span> <span class="nv">key-fn</span> <span class="nv">coll</span><span class="p">)]</span>
	   <span class="p">[</span><span class="nv">k</span> <span class="p">(</span><span class="nf">summarize</span> <span class="nv">v</span><span class="p">)]))</span>
</code></pre></td></tr></table>
</div>
</div><p>自定义的 <code>reduce-by</code> 可以帮助计算数据所有种类的总结, 类似SQL中的GROUP BY查询.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">reduce-by</span>
  <span class="p">[</span><span class="nv">key-fn</span> <span class="nv">f</span> <span class="nv">init</span> <span class="nv">coll</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">reduce </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">summaries</span> <span class="nv">x</span><span class="p">]</span>
	    <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">k</span> <span class="p">(</span><span class="nf">key-fn</span> <span class="nv">x</span><span class="p">)]</span>
	      <span class="c1">;; (f (summaries k init)获取summaries的key对应的值, 如果没找到对应的key, 返回默认值init, 然后使用传入的函数f,组合对应键的值集.</span>
	      <span class="p">(</span><span class="nb">assoc </span><span class="nv">summaries</span> <span class="nv">k</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">summaries</span> <span class="nv">k</span> <span class="nv">init</span><span class="p">)</span> <span class="nv">x</span><span class="p">))))</span>
	  <span class="p">{}</span> <span class="nv">coll</span><span class="p">))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">orders</span>
  <span class="p">[{</span><span class="ss">:product</span> <span class="s">&#34;Clock&#34;</span>, <span class="ss">:customer</span> <span class="s">&#34;Wile Coyote&#34;</span>, <span class="ss">:qty</span> <span class="mi">6</span> <span class="ss">:total</span> <span class="mi">300</span><span class="p">}</span>
   <span class="p">{</span><span class="ss">:product</span> <span class="s">&#34;Dynamite&#34;</span>, <span class="ss">:customer</span> <span class="s">&#34;Wile Coyote&#34;</span>, <span class="ss">:qty</span> <span class="mi">20</span>, <span class="ss">:total</span> <span class="mi">5000</span><span class="p">}</span>
   <span class="p">{</span><span class="ss">:product</span> <span class="s">&#34;Shotgun&#34;</span>, <span class="ss">:customer</span> <span class="s">&#34;Elmer Fudd&#34;</span>, <span class="ss">:qty</span> <span class="mi">2</span>, <span class="ss">:total</span> <span class="mi">800</span><span class="p">}</span>
   <span class="p">{</span><span class="ss">:product</span> <span class="s">&#34;Shells&#34;</span>, <span class="ss">:customer</span> <span class="s">&#34;Elmer Fudd&#34;</span>, <span class="ss">:qty</span> <span class="mi">4</span>, <span class="ss">:total</span> <span class="mi">100</span><span class="p">}</span>
   <span class="p">{</span><span class="ss">:product</span> <span class="s">&#34;Hole&#34;</span>, <span class="ss">:customer</span> <span class="s">&#34;Wile Coyote&#34;</span>, <span class="ss">:qty</span> <span class="mi">1</span>, <span class="ss">:total</span> <span class="mi">1000</span><span class="p">}</span>
   <span class="p">{</span><span class="ss">:product</span> <span class="s">&#34;Anvil&#34;</span>, <span class="ss">:customer</span> <span class="s">&#34;Elmer Fudd&#34;</span>, <span class="ss">:qty</span> <span class="mi">2</span>, <span class="ss">:total</span> <span class="mi">300</span><span class="p">}</span>
   <span class="p">{</span><span class="ss">:product</span> <span class="s">&#34;Anvil&#34;</span>, <span class="ss">:customer</span> <span class="s">&#34;Wile Coyote&#34;</span>, <span class="ss">:qty</span> <span class="mi">6</span>, <span class="ss">:total</span> <span class="mi">900</span><span class="p">}])</span>

<span class="p">(</span><span class="nf">reduce-by</span> <span class="ss">:customer</span> <span class="o">#</span><span class="p">(</span><span class="nb">+ </span><span class="nv">%1</span> <span class="p">(</span><span class="ss">:total</span> <span class="nv">%2</span><span class="p">))</span> <span class="mi">0</span> <span class="nv">orders</span><span class="p">)</span>
<span class="c1">;= {&#34;Wile Coyote&#34; 7200, &#34;Elmer Fudd&#34; 1200}</span>

<span class="p">(</span><span class="nf">reduce-by</span> <span class="ss">:product</span> <span class="o">#</span><span class="p">(</span><span class="nb">conj </span><span class="nv">%1</span> <span class="p">(</span><span class="ss">:customer</span> <span class="nv">%2</span><span class="p">))</span> <span class="o">#</span><span class="p">{}</span> <span class="nv">orders</span><span class="p">)</span>
<span class="o">#</span><span class="nv">_</span><span class="p">{</span><span class="s">&#34;Clock&#34;</span> <span class="o">#</span><span class="p">{</span><span class="s">&#34;Wile Coyote&#34;</span><span class="p">}</span>,
 <span class="s">&#34;Dynamite&#34;</span> <span class="o">#</span><span class="p">{</span><span class="s">&#34;Wile Coyote&#34;</span><span class="p">}</span>,
 <span class="s">&#34;Shotgun&#34;</span> <span class="o">#</span><span class="p">{</span><span class="s">&#34;Elmer Fudd&#34;</span><span class="p">}</span>,
 <span class="s">&#34;Shells&#34;</span> <span class="o">#</span><span class="p">{</span><span class="s">&#34;Elmer Fudd&#34;</span><span class="p">}</span>,
 <span class="s">&#34;Hole&#34;</span> <span class="o">#</span><span class="p">{</span><span class="s">&#34;Wile Coyote&#34;</span><span class="p">}</span>,
 <span class="s">&#34;Anvil&#34;</span> <span class="o">#</span><span class="p">{</span><span class="s">&#34;Elmer Fudd&#34;</span> <span class="s">&#34;Wile Coyote&#34;</span><span class="p">}}</span>

<span class="c1">;;两层排序, 先根据customer排序, 然后根据产品排序</span>
<span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">order</span><span class="p">]</span>
  <span class="p">[(</span><span class="ss">:customer</span> <span class="nv">order</span><span class="p">)</span> <span class="p">(</span><span class="ss">:product</span> <span class="nv">order</span><span class="p">)])</span>

<span class="o">#</span><span class="p">(</span><span class="nb">vector </span><span class="p">(</span><span class="ss">:customer</span> <span class="nv">%</span><span class="p">)</span> <span class="p">(</span><span class="ss">:product</span> <span class="nv">%</span><span class="p">))</span>

<span class="p">(</span><span class="k">fn </span><span class="p">[{</span><span class="ss">:keys</span> <span class="p">[</span><span class="nv">customer</span> <span class="nv">product</span><span class="p">]}]</span>
  <span class="p">[</span><span class="nv">customer</span> <span class="nv">product</span><span class="p">])</span>

<span class="p">(</span><span class="nf">juxt</span> <span class="ss">:customer</span> <span class="ss">:product</span><span class="p">)</span>

<span class="p">(</span><span class="nf">reduce-by</span> <span class="p">(</span><span class="nf">juxt</span> <span class="ss">:customer</span> <span class="ss">:product</span><span class="p">)</span>
	   <span class="o">#</span><span class="p">(</span><span class="nb">+ </span><span class="nv">%1</span> <span class="p">(</span><span class="ss">:total</span> <span class="nv">%2</span><span class="p">))</span> <span class="mi">0</span> <span class="nv">orders</span><span class="p">)</span>
<span class="o">#</span><span class="nv">_</span><span class="p">{[</span><span class="s">&#34;Wile Coyote&#34;</span> <span class="s">&#34;Clock&#34;</span><span class="p">]</span> <span class="mi">300</span>,
   <span class="p">[</span><span class="s">&#34;Wile Coyote&#34;</span> <span class="s">&#34;Dynamite&#34;</span><span class="p">]</span> <span class="mi">5000</span>,
   <span class="p">[</span><span class="s">&#34;Elmer Fudd&#34;</span> <span class="s">&#34;Shotgun&#34;</span><span class="p">]</span> <span class="mi">800</span>,
   <span class="p">[</span><span class="s">&#34;Elmer Fudd&#34;</span> <span class="s">&#34;Shells&#34;</span><span class="p">]</span> <span class="mi">100</span>,
   <span class="p">[</span><span class="s">&#34;Wile Coyote&#34;</span> <span class="s">&#34;Hole&#34;</span><span class="p">]</span> <span class="mi">1000</span>,
   <span class="p">[</span><span class="s">&#34;Elmer Fudd&#34;</span> <span class="s">&#34;Anvil&#34;</span><span class="p">]</span> <span class="mi">300</span>,
   <span class="p">[</span><span class="s">&#34;Wile Coyote&#34;</span> <span class="s">&#34;Anvil&#34;</span><span class="p">]</span> <span class="mi">900</span><span class="p">}</span>

<span class="c1">;; 优化reduce-by, 使其可以工作在嵌套的映射中</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">reduce-by-in</span>
  <span class="p">[</span><span class="nv">keys-fn</span> <span class="nv">f</span> <span class="nv">init</span> <span class="nv">coll</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">reduce </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">summaries</span> <span class="nv">x</span><span class="p">]</span>
	    <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">ks</span> <span class="p">(</span><span class="nf">keys-fn</span> <span class="nv">x</span><span class="p">)]</span>
	      <span class="p">(</span><span class="nf">assoc-in</span> <span class="nv">summaries</span> <span class="nv">ks</span>
			<span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">get-in</span> <span class="nv">summaries</span> <span class="nv">ks</span> <span class="nv">init</span><span class="p">)</span> <span class="nv">x</span><span class="p">))))</span>
	  <span class="p">{}</span> <span class="nv">coll</span><span class="p">))</span>
<span class="p">(</span><span class="nf">reduce-by-in</span> <span class="p">(</span><span class="nf">juxt</span> <span class="ss">:customer</span> <span class="ss">:product</span><span class="p">)</span>
	      <span class="o">#</span><span class="p">(</span><span class="nb">+ </span><span class="nv">%1</span> <span class="p">(</span><span class="ss">:total</span> <span class="nv">%2</span><span class="p">))</span> <span class="mi">0</span> <span class="nv">orders</span><span class="p">)</span>
<span class="o">#</span><span class="nv">_</span><span class="p">{</span><span class="s">&#34;Wile Coyote&#34;</span> <span class="p">{</span><span class="s">&#34;Clock&#34;</span> <span class="mi">300</span>,
		  <span class="s">&#34;Dynamite&#34;</span> <span class="mi">5000</span>,
		  <span class="s">&#34;Hole&#34;</span> <span class="mi">1000</span>,
		  <span class="s">&#34;Anvil&#34;</span> <span class="mi">900</span><span class="p">}</span>,
   <span class="s">&#34;Elmer Fudd&#34;</span> <span class="p">{</span><span class="s">&#34;Shotgun&#34;</span> <span class="mi">800</span>,
		 <span class="s">&#34;Shells&#34;</span> <span class="mi">100</span>,
		 <span class="s">&#34;Anvil&#34;</span> <span class="mi">300</span><span class="p">}}</span>

<span class="c1">;; 通过转换数据结构适应reduce-by函数</span>
<span class="p">(</span><span class="k">def </span><span class="nv">flat-breakup</span>
  <span class="p">{[</span><span class="s">&#34;Wile Coyote&#34;</span> <span class="s">&#34;Anvil&#34;</span><span class="p">]</span> <span class="mi">900</span>,
   <span class="p">[</span><span class="s">&#34;Elmer Fudd&#34;</span> <span class="s">&#34;Anvil&#34;</span><span class="p">]</span> <span class="mi">300</span>,
   <span class="p">[</span><span class="s">&#34;Wile Coyote&#34;</span> <span class="s">&#34;Hole&#34;</span><span class="p">]</span> <span class="mi">1000</span>,
   <span class="p">[</span><span class="s">&#34;Elmer Fudd&#34;</span> <span class="s">&#34;Shells&#34;</span><span class="p">]</span> <span class="mi">100</span>,
   <span class="p">[</span><span class="s">&#34;Elmer Fudd&#34;</span> <span class="s">&#34;Shotgun&#34;</span><span class="p">]</span> <span class="mi">800</span>,
   <span class="p">[</span><span class="s">&#34;Wile Coyote&#34;</span> <span class="s">&#34;Dynamite&#34;</span><span class="p">]</span> <span class="mi">5000</span>,
   <span class="p">[</span><span class="s">&#34;Wile Coyote&#34;</span> <span class="s">&#34;Clock&#34;</span><span class="p">]</span> <span class="mi">300</span><span class="p">})</span>

<span class="p">(</span><span class="nb">reduce </span><span class="o">#</span><span class="p">(</span><span class="nb">apply </span><span class="nv">assoc-in</span> <span class="nv">%1</span> <span class="nv">%2</span><span class="p">)</span> <span class="p">{}</span> <span class="nv">flat-breakup</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="不可变和持久性">不可变和持久性</h3>
<p>Clojure数据结构有两个重要特性</p>
<ul>
<li>不可变</li>
<li>持久性</li>
</ul>
<p>v2是一个单独的数据结构, 这种代码v2并不会完全拷贝v的元素.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">v</span> <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">range </span><span class="mi">1</span><span class="nv">e6</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">count </span><span class="nv">v</span><span class="p">)</span>
<span class="c1">;= 1000000</span>

<span class="p">(</span><span class="k">def </span><span class="nv">v2</span> <span class="p">(</span><span class="nb">conj </span><span class="nv">v</span> <span class="mi">1</span><span class="nv">e6</span><span class="p">))</span>
<span class="p">(</span><span class="nb">count </span><span class="nv">v2</span><span class="p">)</span>
<span class="c1">;= 1000001</span>

<span class="p">(</span><span class="nb">count </span><span class="nv">v</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="持久化和结构化分享">持久化和结构化分享</h4>
<p>对Clojure不可变数据结构是高效的, 和Java的等效操作一样快. 这是因为Clojure的数据结构是持久化的.</p>
<p>持久化实现, 其中集合重用内部结构以最小化表示集合实例的更改版本所需的操作数量, 同时确保集合的所有版本将保持相同效率.</p>
<p>为了达到持久化而不牺牲性能, Clojure数据结构实现了结构化分享. 它们从不深拷贝来满足操作, 象返, 只有受更改影响的数据结构部分被交换出去, 而保留未受影响的引用.</p>
<p>可视化持久:列表</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">a</span> <span class="p">(</span><span class="nb">list </span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">b</span> <span class="p">(</span><span class="nb">conj </span><span class="nv">a</span> <span class="mi">0</span><span class="p">))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">c</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">a</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><figure>
    <img src="/ox-hugo/persist02.png"/> 
</figure>

<figure>
    <img src="/ox-hugo/persist01.png"/> 
</figure>

<p>可视化持久:映射</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">a</span> <span class="p">{</span><span class="ss">:a</span> <span class="mi">5</span> <span class="ss">:b</span> <span class="mi">6</span> <span class="ss">:c</span> <span class="mi">7</span> <span class="ss">:d</span> <span class="mi">8</span><span class="p">})</span>

<span class="c1">;; 往a中添加映射</span>
<span class="p">(</span><span class="k">def </span><span class="nv">b</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">a</span> <span class="ss">:c</span> <span class="mi">0</span><span class="p">))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">c</span> <span class="p">(</span><span class="nb">dissoc </span><span class="nv">a</span> <span class="ss">:d</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><figure>
    <img src="/ox-hugo/persist03.png"/> 
</figure>

<figure>
    <img src="/ox-hugo/persist04.png"/> 
</figure>

<figure>
    <img src="/ox-hugo/persist05.png"/> 
</figure>

<h4 id="瞬态">瞬态</h4>
<p>瞬态集合与持久集合是对立的, 而持久集合保证了先前版本值的完整. 瞬态集合在修改后, 其先前版本的值就不可靠.</p>
<p>Clojure的瞬态集合是可变的</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">x</span> <span class="p">(</span><span class="nf">transient</span> <span class="p">[]))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">y</span> <span class="p">(</span><span class="nf">conj!</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">))</span>

<span class="p">(</span><span class="nb">count </span><span class="nv">y</span><span class="p">)</span>
<span class="c1">;= 1</span>
<span class="p">(</span><span class="nb">count </span><span class="nv">x</span><span class="p">)</span>
<span class="c1">;= 1</span>
</code></pre></td></tr></table>
</div>
</div><p>当更新集合中大量数据时，持久化集合为更新数据分配的内存空间开销会很大。瞬态集合是这种场景的一个优化。</p>
<p><code>into</code> 函数接收一个集合, 一系列的值, 将值拼接在集合的后面. <code>into</code> 使用的是瞬态集合.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">into </span><span class="o">#</span><span class="p">{}</span> <span class="p">(</span><span class="nb">range </span><span class="mi">5</span><span class="p">))</span>

<span class="c1">;= 重新实现into函数</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">native-into</span>
  <span class="p">[</span><span class="nv">coll</span> <span class="nv">source</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">reduce conj </span><span class="nv">coll</span> <span class="nv">source</span><span class="p">))</span>

<span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">into </span><span class="o">#</span><span class="p">{}</span> <span class="p">(</span><span class="nb">range </span><span class="mi">500</span><span class="p">))</span>
   <span class="p">(</span><span class="nf">native-into</span> <span class="o">#</span><span class="p">{}</span> <span class="p">(</span><span class="nb">range </span><span class="mi">500</span><span class="p">)))</span>
<span class="c1">;= true</span>

<span class="p">(</span><span class="nb">time </span><span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="nb">into </span><span class="o">#</span><span class="p">{}</span> <span class="p">(</span><span class="nb">range </span><span class="mi">1</span><span class="nv">e6</span><span class="p">))</span>
	  <span class="nv">nil</span><span class="p">))</span>
<span class="c1">;= &#34;Elapsed time: 560.5775 msecs&#34;</span>
<span class="c1">;= nil</span>

<span class="p">(</span><span class="nb">time </span><span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="nf">native-into</span> <span class="o">#</span><span class="p">{}</span> <span class="p">(</span><span class="nb">range </span><span class="mi">1</span><span class="nv">e6</span><span class="p">))</span>
	  <span class="nv">nil</span><span class="p">))</span>
<span class="c1">;= &#34;Elapsed time: 945.5742 msecs&#34;</span>
<span class="c1">;= nil</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">faster-into</span>
  <span class="p">[</span><span class="nv">coll</span> <span class="nv">source</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">persistent!</span> <span class="p">(</span><span class="nb">reduce </span><span class="nv">conj!</span> <span class="p">(</span><span class="nf">transient</span> <span class="nv">coll</span><span class="p">)</span> <span class="nv">source</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">time </span><span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="nf">faster-into</span> <span class="o">#</span><span class="p">{}</span> <span class="p">(</span><span class="nb">range </span><span class="mi">1</span><span class="nv">e6</span><span class="p">))</span>
	  <span class="nv">nil</span><span class="p">))</span>
<span class="c1">;= &#34;Elapsed time: 690.1804 msecs&#34;</span>
<span class="c1">;= nil</span>
</code></pre></td></tr></table>
</div>
</div><p>虽然 <code>fast-into</code> 中使用的是可变的数据结构, 但是瞬态集合没有离开过该函数的作用域, 说明该函数实际上拥有不可变的语义, 使用持久集合作为参数, 持久集合作为返回值.</p>
<p>只有向量和无序映射有瞬态的变体, 因此 <code>faster-into</code> 函数会在有序集合中失效, 在 <code>faster-into</code> 函数中需要对参数作校验.</p>
<ul>
<li><code>clojure.lang.IEditableCollection</code> 接口表明该集合可以产生瞬态变体.</li>
<li>可以使用 <code>instance?</code> 来判断集合是否属于 <code>clojure.lang.IEditableCollection</code> 接口的实现类.</li>
</ul>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">transient-capable?</span>
  <span class="s">&#34;Returns true if a transient can be obtained for the given collection.
</span><span class="s">  i.e. tests if `(transient coll)` will succeed.&#34;</span>
  <span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">instance? </span><span class="nv">clojure.lang.IEditableCollection</span> <span class="nv">coll</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>瞬态集合的细节, 用作瞬态的基础的持久集合不会受到影响.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">v</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">])</span>
<span class="c1">;= #&#39;chapter3.core/v</span>

<span class="p">(</span><span class="k">def </span><span class="nv">tv</span> <span class="p">(</span><span class="nf">transient</span> <span class="nv">v</span><span class="p">))</span>
<span class="c1">;= #&#39;chapter3.core/tv</span>

<span class="p">(</span><span class="nb">conj </span><span class="nv">v</span> <span class="mi">3</span><span class="p">)</span>
<span class="c1">;= [1 2 3]</span>

<span class="p">(</span><span class="nf">persistent!</span> <span class="nv">tv</span><span class="p">)</span>
<span class="c1">;= [1 2]</span>

<span class="p">(</span><span class="nb">get </span><span class="nv">tv</span> <span class="mi">0</span><span class="p">)</span>
<span class="c1">;= IllegalAccessError Transient used after persistent! call  clojure.lang.PersistentVector$TransientVector.ensureEditable (PersistentVector.java:548)</span>
</code></pre></td></tr></table>
</div>
</div><p>瞬态集合支持他们的持久父类的许多访问函数, 但不是所有.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">nth </span><span class="p">(</span><span class="nf">transient</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">])</span> <span class="mi">1</span><span class="p">)</span>
<span class="c1">;= 2</span>
<span class="p">(</span><span class="nb">get </span><span class="p">(</span><span class="nf">transient</span> <span class="p">{</span><span class="ss">:a</span> <span class="mi">1</span> <span class="ss">:b</span> <span class="mi">2</span><span class="p">})</span> <span class="ss">:a</span><span class="p">)</span>
<span class="c1">;= 1</span>
<span class="p">((</span><span class="nf">transient</span> <span class="p">{</span><span class="ss">:a</span> <span class="mi">1</span> <span class="ss">:b</span> <span class="mi">2</span><span class="p">})</span> <span class="ss">:a</span><span class="p">)</span>
<span class="c1">;= 1</span>
<span class="p">((</span><span class="nf">transient</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">])</span> <span class="mi">1</span><span class="p">)</span>
<span class="c1">;= 2</span>
<span class="p">(</span><span class="nb">find </span><span class="p">(</span><span class="nf">transient</span> <span class="p">{</span><span class="ss">:a</span> <span class="mi">1</span> <span class="ss">:b</span> <span class="mi">2</span><span class="p">})</span> <span class="ss">:a</span><span class="p">)</span>
<span class="c1">;= ClassCastException clojure.lang.PersistentArrayMap$TransientArrayMap cannot be cast to java.util.Map  clojure.lang.RT.find (RT.java:823)</span>
</code></pre></td></tr></table>
</div>
</div><p><code>seq</code> 不支持瞬态. 其基本原理是序列可以比它的源存活得更久, 而且不能依赖瞬态来满足seq本身作为持久集合所作的保证.</p>
<p>所有瞬态函数末尾都以感叹号结尾. 一旦使用瞬态集合使用了这些函数, 这些瞬态集合不应该继续使用(使用副作用的好处), 应该使用这些函数的返回值.</p>
<p>因为没有使用 <code>assoc!</code> 的返回值, 所以使用瞬态map会丢失数据.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">tm</span> <span class="p">(</span><span class="nf">transient</span> <span class="p">{})]</span>
  <span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">x</span> <span class="p">(</span><span class="nb">range </span><span class="mi">100</span><span class="p">)]</span>
    <span class="p">(</span><span class="nf">assoc!</span> <span class="nv">tm</span> <span class="nv">x</span> <span class="mi">0</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">persistent!</span> <span class="nv">tm</span><span class="p">))</span>
<span class="c1">;= {0 0, 1 0, 2 0, 3 0, 4 0, 5 0, 6 0, 7 0}</span>
</code></pre></td></tr></table>
</div>
</div><p>瞬态性不会组合, <code>persistent!</code> 不会遍历嵌套的瞬态集合.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">persistent!</span> <span class="p">(</span><span class="nf">transient</span> <span class="p">[(</span><span class="nf">transient</span> <span class="p">{})]))</span>
<span class="c1">;= [#object[clojure.lang.PersistentArrayMap$TransientArrayMap 0x518ab26f &#34;clojure.lang.PersistentArrayMap$TransientArrayMap@518ab26f&#34;]]</span>

<span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">transient</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">])</span> <span class="p">(</span><span class="nf">transient</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">]))</span>
<span class="c1">;= false</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="元数据">元数据</h3>
<p>元数据可以被附着在任意Clojure数据结构, 而且它通常是映射形式出现.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">a</span> <span class="o">^</span><span class="p">{</span><span class="ss">:created</span> <span class="p">(</span><span class="nf">System/currentTimeMillis</span><span class="p">)}</span>
  <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>

<span class="p">(</span><span class="nb">meta </span><span class="nv">a</span><span class="p">)</span>
<span class="c1">;= {:created 1569293703788}</span>
</code></pre></td></tr></table>
</div>
</div><p>只包含键为关键字且只为Boolean true的槽的元数据可以以简短的形式提供, 并且可以被叠加到正在读取的下一个值.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">meta </span><span class="o">^</span><span class="ss">:private</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>
<span class="c1">;= {:private true}</span>

<span class="p">(</span><span class="nb">meta </span><span class="o">^</span><span class="ss">:private</span> <span class="o">^</span><span class="ss">:dynamic</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>
<span class="c1">;= {:dynamic true, :private true}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>with-meta</code> 和 <code>vary-meta</code> 函数可以更新关联到给定值的元数据.</p>
<ul>
<li><code>with-meta</code> 替换元数据中的值.</li>
<li><code>vary-meta</code> 根据传入的update函数和该函数的其他参数更新元数据的映射.</li>
</ul>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">b</span> <span class="p">(</span><span class="nb">with-meta </span><span class="nv">a</span> <span class="p">(</span><span class="nb">assoc </span><span class="p">(</span><span class="nb">meta </span><span class="nv">a</span><span class="p">)</span>
			   <span class="ss">:modified</span> <span class="p">(</span><span class="nf">System/currentTimeMillis</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">meta </span><span class="nv">b</span><span class="p">)</span>
<span class="c1">;= {:created 1569293703788, :modified 1569294112482}</span>
</code></pre></td></tr></table>
</div>
</div><p>元数据是是关于其他数据的数据, 改变元数据的值不影响原值. 同时改变数据结构返回新的数据结构,仍然保留原来的元数据.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">= </span><span class="o">^</span><span class="p">{</span><span class="ss">:a</span> <span class="mi">5</span><span class="p">}</span> <span class="ss">&#39;any-value</span>
   <span class="o">^</span><span class="p">{</span><span class="ss">:b</span> <span class="mi">6</span><span class="p">}</span> <span class="ss">&#39;any-value</span><span class="p">)</span>

<span class="p">(</span><span class="nb">meta </span><span class="p">(</span><span class="nb">conj </span><span class="nv">a</span> <span class="mi">500</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>使用元数据可以不影响相等性的情况下区别处理不同的数据.</p>
<h3 id="导航-更新和zipper">导航,更新和zipper</h3>
<p>由于不可变数据阻止了向后引用, 所以你不能依赖它们来导航, 一个解决该问题的方法是 <code>zippers</code> , 在命名空间 <code>clojure.zip</code> 中实现.</p>
<p>和Clojure集合一样, <code>zippers</code> 是持久的不可变的, 因此移动或者更新 <code>zipper</code> 从而返回新的 <code>zipper</code> 不会改变原来的结构.</p>
<h4 id="操作zipper">操作zipper</h4>
<p><code>clojure.zip</code> 提供了通用的 <code>zipper</code> 工厂函数和三个特别的函数</p>
<ul>
<li><code>seq-zip</code> 可以用于嵌套的序列</li>
<li><code>vector-zip</code> 可以用于嵌套的向量</li>
<li><code>xml-zip</code> 用于表示每个 <code>clojure.xml</code> 的XML数据</li>
</ul>
<p><code>zipper</code> 移动函数</p>
<ul>
<li><code>up</code> 移动到树根</li>
<li><code>down</code> 移动到叶子节点</li>
<li><code>left</code> 移动到左边的兄弟节点</li>
<li><code>right</code> 移动到右边的兄弟节点</li>
<li><code>leftmost</code> 移动到第一个兄弟节点</li>
<li><code>rightmost</code> 移动到最后一个兄弟节点</li>
</ul>
<p>为了检查当前位置和节点, <code>clojure.zip</code> 包含了下列函数</p>
<ul>
<li><code>node</code> 当前节点</li>
<li><code>branch?</code> 当前节点是不是分支</li>
<li><code>children</code> 分支的子节点</li>
<li><code>lefts</code> 当前节点所有的左兄弟节点</li>
<li><code>rights</code> 当前节点所有的右兄弟节点</li>
<li><code>root</code> 使用zipper修改树时, root是关键</li>
</ul>
<p>zipper操作函数</p>
<ul>
<li><code>remove</code> 移除当前节点</li>
<li><code>replace</code> 替换节点</li>
<li><code>insert</code> 插入子节点到前面</li>
<li><code>append</code> 添加子节点到后面</li>
<li><code>edit</code> 更新节点</li>
</ul>
<h4 id="自定义zipper">自定义zipper</h4>
<p><code>zipper</code> 函数创建zipper, 通常接受3个参数, 后面是应用zipper结构的根节点</p>
<ul>
<li>一个如果节点有子节点返回真的谓词</li>
<li>一个给定分支节点, 返回其分支的序列集合的函数</li>
<li>一个给定已存在的节点和子节点的序列集合, 返回新分支节点函数</li>
</ul>
<p>使用zipper自定义数据方案: 使用向量代替HTML元素</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">html-zip</span> <span class="p">[</span><span class="nv">root</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">z/zipper</span>
   <span class="nv">vector?</span>
   <span class="p">(</span><span class="k">fn </span><span class="p">[[</span><span class="nv">tagname</span> <span class="o">&amp;</span> <span class="nv">xs</span><span class="p">]]</span>
     <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">map? </span><span class="p">(</span><span class="nb">first </span><span class="nv">xs</span><span class="p">))</span> <span class="p">(</span><span class="nb">next </span><span class="nv">xs</span><span class="p">)</span> <span class="nv">xs</span><span class="p">))</span>
   <span class="p">(</span><span class="k">fn </span><span class="p">[[</span><span class="nv">tagname</span> <span class="o">&amp;</span> <span class="nv">xs</span><span class="p">]</span> <span class="nv">children</span><span class="p">]</span>
     <span class="p">(</span><span class="nb">into </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">map? </span><span class="p">(</span><span class="nb">first </span><span class="nv">xs</span><span class="p">))</span>
	     <span class="p">[</span><span class="nv">tagname</span> <span class="p">(</span><span class="nb">first </span><span class="nv">xs</span><span class="p">)]</span>
	     <span class="p">[</span><span class="nv">tagname</span><span class="p">])</span>
	   <span class="nv">children</span><span class="p">))</span>
   <span class="nv">root</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">wrap</span>
  <span class="s">&#34;Wraps the current node in the specified tag and attributes.&#34;</span>
  <span class="p">([</span><span class="nv">loc</span> <span class="nv">tag</span><span class="p">]</span>
   <span class="p">(</span><span class="nf">z/edit</span> <span class="nv">loc</span> <span class="o">#</span><span class="p">(</span><span class="nb">vector </span><span class="nv">tag</span> <span class="nv">%</span><span class="p">)))</span>
  <span class="p">([</span><span class="nv">loc</span> <span class="nv">tag</span> <span class="nv">attrs</span><span class="p">]</span>
   <span class="p">(</span><span class="nf">z/edit</span> <span class="nv">loc</span> <span class="o">#</span><span class="p">(</span><span class="nb">vector </span><span class="nv">tag</span> <span class="nv">attrs</span> <span class="nv">%</span><span class="p">))))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">h</span> <span class="p">[</span><span class="ss">:body</span> <span class="p">[</span><span class="ss">:h1</span> <span class="s">&#34;Clojure&#34;</span><span class="p">]</span>
	<span class="p">[</span><span class="ss">:p</span> <span class="s">&#34;What a wonderful language!&#34;</span><span class="p">]])</span>

<span class="p">(</span><span class="nb">-&gt; </span><span class="nv">h</span> <span class="nv">html-zip</span> <span class="nv">z/down</span> <span class="nv">z/right</span> <span class="nv">z/down</span> <span class="p">(</span><span class="nf">wrap</span> <span class="ss">:b</span><span class="p">)</span> <span class="nv">z/root</span><span class="p">)</span>

</code></pre></td></tr></table>
</div>
</div>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">devinkin</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2020-04-18
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/clojure/">Clojure</a>
          <a href="/tags/lisp/">Lisp</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/clojureprogramming/chapter4/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Clojure编程-第四章-并发和并行</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/clojureprogramming/chapter2/">
            <span class="next-text nav-default">Clojure编程-第二章-函数式编程</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="https://github.com/DevinKin" class="iconfont icon-github" title="github"></a>
  <a href="https://devinkin.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2019 - 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">devinkin</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="https://devinkin.github.io/js/main.4d21c1cefdf1cd0b77ef59bab2d1bbe3112fc9d6cc04710bb1f0b1fd7b891f11.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"  integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>








</body>
</html>
